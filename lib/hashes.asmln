IMPORT(collection)

# Shared bit helpers
BYTE_MASK = 11111111
SHIFT_8 = 1000
SHIFT_16 = 10000
SHIFT_24 = 11000
SHIFT_32 = 100000
SHIFT_64 = 1000000
MASK32 = SUB( POW(10, SHIFT_32), 1 )
MASK64 = SUB( POW(10, SHIFT_64), 1 )

FUNC ROTR32(x, n){
	v = BAND(x, MASK32)
	IF( EQ(n, 0) ){ RETURN(v) }
	RETURN( BAND( BOR( SHR(v, n), SHL(v, SUB(SHIFT_32, n)) ), MASK32) )
}

FUNC ROTL64(x, n){
	v = BAND(x, MASK64)
	IF( EQ(n, 0) ){ RETURN(v) }
	RETURN( BAND( BOR( SHL(v, n), SHR(v, SUB(SHIFT_64, n)) ), MASK64) )
}

# === SHA-256 ===
FUNC SHA256_K(){
	k = collection.COL_EMPTY()
	k = collection.COL_PUSH(k, 01000010100010100010111110011000)
	k = collection.COL_PUSH(k, 01110001001101110100010010010001)
	k = collection.COL_PUSH(k, 10110101110000001111101111001111)
	k = collection.COL_PUSH(k, 11101001101101011101101110100101)
	k = collection.COL_PUSH(k, 00111001010101101100001001011011)
	k = collection.COL_PUSH(k, 01011001111100010001000111110001)
	k = collection.COL_PUSH(k, 10010010001111111000001010100100)
	k = collection.COL_PUSH(k, 10101011000111000101111011010101)
	k = collection.COL_PUSH(k, 11011000000001111010101010011000)
	k = collection.COL_PUSH(k, 00010010100000110101101100000001)
	k = collection.COL_PUSH(k, 00100100001100011000010110111110)
	k = collection.COL_PUSH(k, 01010101000011000111110111000011)
	k = collection.COL_PUSH(k, 01110010101111100101110101110100)
	k = collection.COL_PUSH(k, 10000000110111101011000111111110)
	k = collection.COL_PUSH(k, 10011011110111000000011010100111)
	k = collection.COL_PUSH(k, 11000001100110111111000101110100)
	k = collection.COL_PUSH(k, 11100100100110110110100111000001)
	k = collection.COL_PUSH(k, 11101111101111100100011110000110)
	k = collection.COL_PUSH(k, 00001111110000011001110111000110)
	k = collection.COL_PUSH(k, 00100100000011001010000111001100)
	k = collection.COL_PUSH(k, 00101101111010010010110001101111)
	k = collection.COL_PUSH(k, 01001010011101001000010010101010)
	k = collection.COL_PUSH(k, 01011100101100001010100111011100)
	k = collection.COL_PUSH(k, 01110110111110011000100011011010)
	k = collection.COL_PUSH(k, 10011000001111100101000101010010)
	k = collection.COL_PUSH(k, 10101000001100011100011001101101)
	k = collection.COL_PUSH(k, 10110000000000110010011111001000)
	k = collection.COL_PUSH(k, 10111111010110010111111111000111)
	k = collection.COL_PUSH(k, 11000110111000000000101111110011)
	k = collection.COL_PUSH(k, 11010101101001111001000101000111)
	k = collection.COL_PUSH(k, 00000110110010100110001101010001)
	k = collection.COL_PUSH(k, 00010100001010010010100101100111)
	k = collection.COL_PUSH(k, 00100111101101110000101010000101)
	k = collection.COL_PUSH(k, 00101110000110110010000100111000)
	k = collection.COL_PUSH(k, 01001101001011000110110111111100)
	k = collection.COL_PUSH(k, 01010011001110000000110100010011)
	k = collection.COL_PUSH(k, 01100101000010100111001101010100)
	k = collection.COL_PUSH(k, 01110110011010100000101010111011)
	k = collection.COL_PUSH(k, 10000001110000101100100100101110)
	k = collection.COL_PUSH(k, 10010010011100100010110010000101)
	k = collection.COL_PUSH(k, 10100010101111111110100010100001)
	k = collection.COL_PUSH(k, 10101000000110100110011001001011)
	k = collection.COL_PUSH(k, 11000010010010111000101101110000)
	k = collection.COL_PUSH(k, 11000111011011000101000110100011)
	k = collection.COL_PUSH(k, 11010001100100101110100000011001)
	k = collection.COL_PUSH(k, 11010110100110010000011000100100)
	k = collection.COL_PUSH(k, 11110100000011100011010110000101)
	k = collection.COL_PUSH(k, 00010000011010101010000001110000)
	k = collection.COL_PUSH(k, 00011001101001001100000100010110)
	k = collection.COL_PUSH(k, 00011110001101110110110000001000)
	k = collection.COL_PUSH(k, 00100111010010000111011101001100)
	k = collection.COL_PUSH(k, 00110100101100001011110010110101)
	k = collection.COL_PUSH(k, 00111001000111000000110010110011)
	k = collection.COL_PUSH(k, 01001110110110001010101001001010)
	k = collection.COL_PUSH(k, 01011011100111001100101001001111)
	k = collection.COL_PUSH(k, 01101000001011100110111111110011)
	k = collection.COL_PUSH(k, 01110100100011111000001011101110)
	k = collection.COL_PUSH(k, 01111000101001010110001101101111)
	k = collection.COL_PUSH(k, 10000100110010000111100000010100)
	k = collection.COL_PUSH(k, 10001100110001110000001000001000)
	k = collection.COL_PUSH(k, 10010000101111101111111111111010)
	k = collection.COL_PUSH(k, 10100100010100000110110011101011)
	k = collection.COL_PUSH(k, 10111110111110011010001111110111)
	k = collection.COL_PUSH(k, 11000110011100010111100011110010)
	RETURN(k)
}

FUNC SHA256_IV(){
	iv = collection.COL_EMPTY()
	iv = collection.COL_PUSH(iv, 01101010000010011110011001100111)
	iv = collection.COL_PUSH(iv, 10111011011001111010111010000101)
	iv = collection.COL_PUSH(iv, 00111100011011101111001101110010)
	iv = collection.COL_PUSH(iv, 10100101010011111111010100111010)
	iv = collection.COL_PUSH(iv, 01010001000011100101001001111111)
	iv = collection.COL_PUSH(iv, 10011011000001010110100010001100)
	iv = collection.COL_PUSH(iv, 00011111100000111101100110101011)
	iv = collection.COL_PUSH(iv, 01011011111000001100110100011001)
	RETURN(iv)
}

FUNC SHA256_BIG_SIG0(x){
	RETURN( BXOR( BXOR( ROTR32(x, 10), ROTR32(x, 1101) ), ROTR32(x, 10110) ) )
}

FUNC SHA256_BIG_SIG1(x){
	RETURN( BXOR( BXOR( ROTR32(x, 110), ROTR32(x, 1011) ), ROTR32(x, 11001) ) )
}

FUNC SHA256_SMALL_SIG0(x){
	RETURN( BXOR( BXOR( ROTR32(x, 111), ROTR32(x, 10010) ), SHR(x, 11) ) )
}

FUNC SHA256_SMALL_SIG1(x){
	RETURN( BXOR( BXOR( ROTR32(x, 10001), ROTR32(x, 10011) ), SHR(x, 1010) ) )
}

FUNC SHA256_CH(x, y, z){
	RETURN( BXOR( BAND(x, y), BAND( BNOT(x), z ) ) )
}

FUNC SHA256_MAJ(x, y, z){
	RETURN( BXOR( BXOR( BAND(x, y), BAND(x, z) ), BAND(y, z) ) )
}

FUNC SHA256_BYTES_TO_WORD(b0, b1, b2, b3){
	RETURN( BOR( SHL(BAND(b0, BYTE_MASK), SHIFT_24), BOR( SHL(BAND(b1, BYTE_MASK), SHIFT_16), BOR( SHL(BAND(b2, BYTE_MASK), SHIFT_8), BAND(b3, BYTE_MASK) ) ) ) )
}

FUNC SHA256_WORD_TO_BYTES(word){
	w = BAND(word, MASK32)
	out = collection.COL_EMPTY()
	out = collection.COL_PUSH(out, BAND( DIV(w, POW(10, SHIFT_24)), BYTE_MASK))
	out = collection.COL_PUSH(out, BAND( DIV(w, POW(10, SHIFT_16)), BYTE_MASK))
	out = collection.COL_PUSH(out, BAND( DIV(w, POW(10, SHIFT_8)), BYTE_MASK))
	out = collection.COL_PUSH(out, BAND(w, BYTE_MASK))
	RETURN(out)
}

FUNC SHA256_PAD(message){
	msg = message
	bit_len = MUL( collection.GET_COUNT(msg), SHIFT_8 )
	msg = collection.COL_PUSH(msg, 10000000)  # 0x80

	block_bytes = 1000000  # 64
	pad_target = 111000     # 56
	WHILE( NOT( EQ( MOD(collection.GET_COUNT(msg), block_bytes), pad_target ) ) ){
		msg = collection.COL_PUSH(msg, 0)
	}

	i = 111  # 7
	WHILE( GTE(i, 0) ){
		shift = MUL(i, SHIFT_8)
		b = BAND( DIV(bit_len, POW(10, shift)), BYTE_MASK)
		msg = collection.COL_PUSH(msg, b)
		i = SUB(i, 1)
	}
	RETURN(msg)
}

FUNC SHA256(message_bytes){
	k = SHA256_K()
	hvals = SHA256_IV()
	msg = SHA256_PAD(message_bytes)

	block_size = 1000000  # 64 bytes
	total = collection.GET_COUNT(msg)
	offset = 0
	WHILE( LT(offset, total) ){
		w = collection.COL_EMPTY()
		j = 0
		WHILE( LT(j, 10000) ){
			base = ADD(offset, MUL(j, 100))
			w = collection.COL_PUSH(w, SHA256_BYTES_TO_WORD( collection.COL_GET(msg, base), collection.COL_GET(msg, ADD(base,1)), collection.COL_GET(msg, ADD(base,10)), collection.COL_GET(msg, ADD(base,11)) ))
			j = ADD(j, 1)
		}

		idx = 10000
		WHILE( LT(idx, 1000000) ){
			s0 = SHA256_SMALL_SIG0( collection.COL_GET(w, SUB(idx, 1111)) )
			s1 = SHA256_SMALL_SIG1( collection.COL_GET(w, SUB(idx, 10)) )
			new_w = BAND( ADD( ADD( ADD(s1, collection.COL_GET(w, SUB(idx, 111))), collection.COL_GET(w, SUB(idx, 10000)) ), s0 ), MASK32)
			w = collection.COL_PUSH(w, new_w)
			idx = ADD(idx, 1)
		}

		a = collection.COL_GET(hvals,0)
		b = collection.COL_GET(hvals,1)
		c = collection.COL_GET(hvals,10)
		d = collection.COL_GET(hvals,11)
		e = collection.COL_GET(hvals,100)
		f = collection.COL_GET(hvals,101)
		g = collection.COL_GET(hvals,110)
		h = collection.COL_GET(hvals,111)

		t = 0
		WHILE( LT(t, 1000000) ){
			T1 = BAND( ADD( ADD( ADD( ADD(h, SHA256_BIG_SIG1(e)), SHA256_CH(e, f, g) ), collection.COL_GET(k, t) ), collection.COL_GET(w, t) ), MASK32)
			T2 = BAND( ADD( SHA256_BIG_SIG0(a), SHA256_MAJ(a, b, c) ), MASK32)

			h = g
			g = f
			f = e
			e = BAND( ADD(d, T1), MASK32)
			d = c
			c = b
			b = a
			a = BAND( ADD(T1, T2), MASK32)

			t = ADD(t, 1)
		}

		h0 = BAND( ADD(collection.COL_GET(hvals,0), a), MASK32)
		h1 = BAND( ADD(collection.COL_GET(hvals,1), b), MASK32)
		h2 = BAND( ADD(collection.COL_GET(hvals,10), c), MASK32)
		h3 = BAND( ADD(collection.COL_GET(hvals,11), d), MASK32)
		h4 = BAND( ADD(collection.COL_GET(hvals,100), e), MASK32)
		h5 = BAND( ADD(collection.COL_GET(hvals,101), f), MASK32)
		h6 = BAND( ADD(collection.COL_GET(hvals,110), g), MASK32)
		h7 = BAND( ADD(collection.COL_GET(hvals,111), h), MASK32)

		hvals = collection.COL_EMPTY()
		hvals = collection.COL_PUSH(hvals, h0)
		hvals = collection.COL_PUSH(hvals, h1)
		hvals = collection.COL_PUSH(hvals, h2)
		hvals = collection.COL_PUSH(hvals, h3)
		hvals = collection.COL_PUSH(hvals, h4)
		hvals = collection.COL_PUSH(hvals, h5)
		hvals = collection.COL_PUSH(hvals, h6)
		hvals = collection.COL_PUSH(hvals, h7)

		offset = ADD(offset, block_size)
	}

	digest = collection.COL_EMPTY()
	hi = 0
	WHILE( LT(hi, 1000) ){
		word_bytes = SHA256_WORD_TO_BYTES( collection.COL_GET(hvals, hi) )
		digest = collection.COL_PUSH(digest, collection.COL_GET(word_bytes,0))
		digest = collection.COL_PUSH(digest, collection.COL_GET(word_bytes,1))
		digest = collection.COL_PUSH(digest, collection.COL_GET(word_bytes,10))
		digest = collection.COL_PUSH(digest, collection.COL_GET(word_bytes,11))
		hi = ADD(hi, 1)
	}
	RETURN(digest)
}