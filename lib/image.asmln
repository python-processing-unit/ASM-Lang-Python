# Image loading helpers for ASM-Lang
# Backed by ext/image.py (stdlib-only, prefers Windows GDI+).
#
# API (operators provided by the model/extension):
# LOAD_PNG(STR: path):TNS[height,width,[r,g,b,a]]
# LOAD_JPEG(STR: path):TNS[height,width,[r,g,b,a]]
# LOAD_BMP(STR: path):TNS[height,width,[r,g,b,a]]
# SAVE_PNG(TNS: img, STR: path, INT: compression_level)
# SAVE_JPEG(TNS: img, STR: path, INT: compression_level)
# SAVE_BMP(TNS: img, STR: path)
# POLYGON(TNS:img, TNS:points[[x,y]...], TNS:color[r,g,b,a], INT:fill=1, INT:thickness=1):TNS
# RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color[r,g,b,a], INT: fill = 1, INT: thickness = 1):TNS  # wraps POLYGON
# ELLIPSE(TNS: img, TNS: center, INT: rx, INT: ry, TNS: color[r,g,b,a], INT: fill = 1, INT: thickness = 1):TNS
# SQUARE(TNS: img, INT: x, INT: y, INT: size, TNS: color, INT: fill, INT: thickness):TNS
# CIRCLE(TNS: img, TNS: center, INT: radius, TNS: color, INT: fill, INT: thickness):TNS
# WIDTH(TNS: img):INT
# HEIGHT(TNS: img):INT
# CHANNELS(TNS: img):INT
# PIXEL(TNS: img, INT: x, INT: y):TNS
# R(TNS: img, INT: x, INT: y):INT
# G(TNS: img, INT: x, INT: y):INT
# B(TNS: img, INT: x, INT: y):INT
# A(TNS: img, INT: x, INT: y):INT
# FLIP_V(TNS: img):TNS
# FLIP_H(TNS: img):TNS
# INVERT(TNS: img):TNS
# SCALE(TNS: src, INT: scale_x, INT: scale_y, INT: antialiasing = 1):TNS
# CROP(TNS: img, INT: tl, INT: tr, INT: bl, INT: br):TNS
# ROTATE(TNS: img, FLT: degrees):TNS
# BLIT(TNS: src, TNS: dest, INT: x, INT: y, INT: mixalpha = 1):TNS
# GRAYSCALE(TNS: img):TNS  # three-channel grayscale (rgb=luminance, alpha preserved)
# REPLACE_COLOR(TNS: img, TNS: target_color, TNS: replacement_color):TNS
# BLUR(TNS: img, INT: radius):TNS  # gaussian blur with integer radius
# SHOW(TNS: img, STR: window):INT  # saves to temp file and opens with default viewer (Windows only)
#
# The returned tensor layout is [row][column][channel] with 1-based indexing
# in user code. Channels are ordered r,g,b,a and values are 0..255.

FUNC WIDTH(TNS: img):INT{
    RETURN(TLEN(img, 10))
}

FUNC HEIGHT(TNS: img):INT{
    RETURN(TLEN(img, 1))
}

FUNC CHANNELS(TNS: img):INT{
    RETURN(TLEN(img, 11))
}

FUNC PIXEL(TNS: img, INT: x, INT: y):TNS{
    RETURN([img[y,x,1], img[y,x,10], img[y,x,11], img[y,x,100]])
}

FUNC R(TNS: img, INT: x, INT: y):INT{
    RETURN(img[y,x,1])
}

FUNC G(TNS: img, INT: x, INT: y):INT{
    RETURN(img[y,x,10])
}

FUNC B(TNS: img, INT: x, INT: y):INT{
    RETURN(img[y,x,11])
}

FUNC A(TNS: img, INT: x, INT: y):INT{
    RETURN(img[y,x,100])
}

FUNC FLIP_V(TNS: img):TNS{
    RETURN(TFLIP(img, 1))
}

FUNC FLIP_H(TNS: img):TNS{
    RETURN(TFLIP(img, 10))
}

FUNC INVERT(TNS: img):TNS{
    TNS: shape = SHAPE(img)
    INT: h = HEIGHT(img)
    INT: w = WIDTH(img)
    # Create an output tensor with the same shape, initialized to 0
    TNS: out = TNS(shape, 0)
    DEL(shape)
    FOR(y, h){
        FOR(x, w){
            INT: r = R(img, x, y)
            INT: g = G(img, x, y)
            INT: b = B(img, x, y)
            INT: a = A(img, x, y)
            out[y,x,1] = SUB(11111111, r)
            out[y,x,10] = SUB(11111111, g)
            out[y,x,11] = SUB(11111111, b)
            out[y,x,100] = a
        }
    }
    DEL(h)
    DEL(w)
    DEL(r)
    DEL(g)
    DEL(b)
    DEL(a)
    POP(out)
}

FUNC RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color, INT: fill, INT: thickness):TNS{
    TNS: pts = [ ^
        [x, y], ^
        [ADD(x, SUB(width, 1)), y], ^
        [ADD(x, SUB(width, 1)), ADD(y, SUB(height, 1))], ^
        [x, ADD(y, SUB(height, 1))], ^
        [x, y] ^
    ]
    RETURN(image.POLYGON(img, pts, color, fill, thickness))
}

FUNC RECTANGLE(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(RECT(img, x, y, width, height, color, fill, thickness))
}

FUNC FILL_RECT(TNS: img, INT: x, INT: y, INT: width, INT: height, TNS: color):TNS{
    RETURN(RECT(img, x, y, width, height, color, 1, 1))
}

FUNC FILL_ELLIPSE(TNS: img, TNS: center, INT: rx, INT: ry, TNS: color):TNS{
    RETURN(image.ELLIPSE(img, center, rx, ry, color, 1, 1))
}
 
FUNC SQUARE(TNS: img, INT: x, INT: y, INT: size, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(RECT(img, x, y, size, size, color, fill, thickness))
}

FUNC CIRCLE(TNS: img, TNS: center, INT: radius, TNS: color, INT: fill, INT: thickness):TNS{
    RETURN(image.ELLIPSE(img, center, radius, radius, color, fill, thickness))
}

FUNC SHOW(TNS: img, STR: window):INT{
    # Save the image to the provided path and open it with the system default
    # viewer on Windows. `window` is treated as the target file path.
    SAVE_PNG(img, window, 0)
    # ShellExecuteW(hwnd, operation, file, params, dir, showcmd)
    # Use NULL hwnd (0), operation "open", empty params and dir, showcmd=1
    win32.WIN_CALL("shell32", "ShellExecuteW", "PSSSSI", "P", 0, "open", window, "", "", 1)
    RETURN(0)
}