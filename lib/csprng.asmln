#ChaCha20-based cryptographically secure pseudorandom number generator
#
# API:
# CS_PRNG_SEED(INT:seed) -> INT
# CS_PRNG_NEXT() -> INT
# CS_PRNG_RANGE(INT:max) -> INT
# CS_PRNG_RANGE_MIN_MAX(INT:min, INT:max) -> INT

INT: MASK32 = SUB( POW(10,100000), 1 )  # 2^32-1

# ChaCha20 constants ("expand 32-byte k")
INT: CH_CONST0 = 01100001011100000111000001100101
INT: CH_CONST1 = 00110011001000000110010001101110
INT: CH_CONST2 = 01111001011000100010110100110010
INT: CH_CONST3 = 01101011001000000110010101110100

TNS: ch_key = [0,0,0,0,0,0,0,0]
TNS: ch_nonce = [0,0,0]
INT: ch_counter = 0
TNS: ch_buf = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
INT: ch_buf_pos = 10000  # 16 -> force refill

FUNC ROTL32(INT:x, INT:n):INT{
    INT: x32 = BAND(x, MASK32)
    INT: left = BAND( SHL(x32, n), MASK32 )
    INT: right = DIV( x32, POW(10, SUB(100000, n)) )
    RETURN( BOR(left, right) )
}

FUNC QR(INT:a, INT:b, INT:c, INT:d):TNS{
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 10000 )   # 16
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 1100 )    # 12
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 1000 )    # 8
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 111 )     # 7
    TNS: coll = [a, b, c, d]
    RETURN(coll)
}

FUNC CHACHA_BLOCK():TNS{
    INT: x0 = CH_CONST0
    INT: x1 = CH_CONST1
    INT: x2 = CH_CONST2
    INT: x3 = CH_CONST3
    INT: x4 = ch_key[1]
    INT: x5 = ch_key[10]
    INT: x6 = ch_key[11]
    INT: x7 = ch_key[100]
    INT: x8 = ch_key[101]
    INT: x9 = ch_key[110]
    INT: x10 = ch_key[111]
    INT: x11 = ch_key[1000]
    INT: x12 = ch_counter
    INT: x13 = ch_nonce[1]
    INT: x14 = ch_nonce[10]
    INT: x15 = ch_nonce[11]
    INT: i = 0
    WHILE( LT(i, 1010) ){  # 10 double-rounds
        TNS: qr = QR(x0, x4, x8,  x12)
        x0 = qr[1]
        x4 = qr[10]
        x8  = qr[11]
        x12 = qr[100]
        qr = QR(x1, x5, x9,  x13)
        x1 = qr[1]
        x5 = qr[10]
        x9  = qr[11]
        x13 = qr[100]
        qr = QR(x2, x6, x10, x14)
        x2 = qr[1]
        x6 = qr[10]
        x10 = qr[11]
        x14 = qr[100]
        qr = QR(x3, x7, x11, x15)
        x3 = qr[1]
        x7 = qr[10]
        x11 = qr[11]
        x15 = qr[100]

        qr = QR(x0, x5, x10, x15)
        x0 = qr[1]
        x5 = qr[10]
        x10 = qr[11]
        x15 = qr[100]
        qr = QR(x1, x6, x11, x12)
        x1 = qr[1]
        x6 = qr[10]
        x11 = qr[11]
        x12 = qr[100]
        qr = QR(x2, x7, x8,  x13)
        x2 = qr[1]
        x7 = qr[10]
        x8  = qr[11]
        x13 = qr[100]
        qr = QR(x3, x4, x9,  x14)
        x3 = qr[1]
        x4 = qr[10]
        x9  = qr[11]
        x14 = qr[100]

        i = ADD(i, 1)
    }

    x0 = BAND( ADD(x0, CH_CONST0), MASK32 )
    x1 = BAND( ADD(x1, CH_CONST1), MASK32 )
    x2 = BAND( ADD(x2, CH_CONST2), MASK32 )
    x3 = BAND( ADD(x3, CH_CONST3), MASK32 )
    x4 = BAND( ADD(x4, ch_key[1]), MASK32 )
    x5 = BAND( ADD(x5, ch_key[10]), MASK32 )
    x6 = BAND( ADD(x6, ch_key[11]), MASK32 )
    x7 = BAND( ADD(x7, ch_key[100]), MASK32 )
    x8 = BAND( ADD(x8, ch_key[101]), MASK32 )
    x9 = BAND( ADD(x9, ch_key[110]), MASK32 )
    x10 = BAND( ADD(x10, ch_key[111]), MASK32 )
    x11 = BAND( ADD(x11, ch_key[1000]), MASK32 )
    x12 = BAND( ADD(x12, ch_counter), MASK32 )
    x13 = BAND( ADD(x13, ch_nonce[1]), MASK32 )
    x14 = BAND( ADD(x14, ch_nonce[10]), MASK32 )
    x15 = BAND( ADD(x15, ch_nonce[11]), MASK32 )

    TNS: out = [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15]
    RETURN(out)
}

FUNC REFILL_BUF():INT{
    ch_buf = CHACHA_BLOCK()
    ch_buf_pos = 0
    ch_counter = BAND( ADD(ch_counter, 1), MASK32 )
    RETURN(0)
}

FUNC DERIVE_KEY_AND_NONCE(INT:seed):INT{
    INT: s = BAND(seed, MASK32)
    INT: i = 0
    WHILE( LT(i, 1000) ){  # 8 key words (1000 == 8)
        s = BAND( ADD( MUL(s, ^
            01000001110001100100111001101101), ^
            00000000000000000011000000111001 ), ^
            MASK32 ^
        )
        ch_key[ ADD(i, 1) ] = s
        i = ADD(i, 1)
    }
    INT: j = 0
    WHILE( LT(j, 11) ){  # 3 nonce words (11 == 3)
        s = BAND( ADD( MUL(s, ^
            01000001110001100100111001101101), ^
            00000000000000000011000000111001 ), ^
            MASK32 ^
        )
        ch_nonce[ ADD(j, 1) ] = s
        j = ADD(j, 1)
    }
    RETURN(0)
}

FUNC CS_PRNG_SEED(INT:seed):INT{
    DERIVE_KEY_AND_NONCE(seed)
    ch_counter = 0
    ch_buf = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ch_buf_pos = 10000  # 16
    RETURN(ch_counter)
}

FUNC CS_PRNG_NEXT():INT{
    IF( GTE(ch_buf_pos, 10000) ){  # 16
        REFILL_BUF()
    }
    INT: v = ch_buf[ ADD(ch_buf_pos, 1) ]
    ch_buf_pos = ADD(ch_buf_pos, 1)
    RETURN(v)
}

FUNC CS_PRNG_RANGE(INT:max):INT{
    ASSERT( GT(max, 0) )
    RETURN( MOD(CS_PRNG_NEXT(), max) )
}

FUNC CS_PRNG_RANGE_MIN_MAX(INT:min, INT:max):INT{
    ASSERT( LTE(min, max) )
    INT: range = SUB(max, min)
    IF( EQ(range, 0) ){ RETURN(min) }
    ASSERT( GT(range, 0) )
    INT: offset = CS_PRNG_RANGE(range)
    RETURN( ADD(offset, min) )
}