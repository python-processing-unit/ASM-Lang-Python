#ChaCha20-based cryptographically secure pseudorandom number generator

INT: MASK32 = SUB( POW(10,100000), 1 )  # 2^32-1

# ChaCha20 constants ("expand 32-byte k")
INT: CH_CONST0 = 01100001011100000111000001100101
INT: CH_CONST1 = 00110011001000000110010001101110
INT: CH_CONST2 = 01111001011000100010110100110010
INT: CH_CONST3 = 01101011001000000110010101110100

INT: ch_key0 = 0
INT: ch_key1 = 0
INT: ch_key2 = 0
INT: ch_key3 = 0
INT: ch_key4 = 0
INT: ch_key5 = 0
INT: ch_key6 = 0
INT: ch_key7 = 0
INT: ch_nonce0 = 0
INT: ch_nonce1 = 0
INT: ch_nonce2 = 0
INT: ch_counter = 0
TNS: ch_buf = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
INT: ch_buf_pos = 10000  # 16 -> force refill

FUNC ROTL32(INT:x, INT:n):INT{
    INT: x32 = BAND(x, MASK32)
    INT: left = BAND( SHL(x32, n), MASK32 )
    INT: right = DIV( x32, POW(10, SUB(100000, n)) )
    RETURN( BOR(left, right) )
}

FUNC QR(INT:a, INT:b, INT:c, INT:d):TNS{
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 10000 )   # 16
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 1100 )    # 12
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 1000 )    # 8
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 111 )     # 7
    TNS: coll = [a, b, c, d]
    RETURN(coll)
}

FUNC CHACHA_BLOCK():TNS{
    INT: x0 = CH_CONST0
    INT: x1 = CH_CONST1
    INT: x2 = CH_CONST2
    INT: x3 = CH_CONST3
    INT: x4 = ch_key0
    INT: x5 = ch_key1
    INT: x6 = ch_key2
    INT: x7 = ch_key3
    INT: x8 = ch_key4
    INT: x9 = ch_key5
    INT: x10 = ch_key6
    INT: x11 = ch_key7
    INT: x12 = ch_counter
    INT: x13 = ch_nonce0
    INT: x14 = ch_nonce1
    INT: x15 = ch_nonce2
    INT: i = 0
    WHILE( LT(i, 1010) ){  # 10 double-rounds
        TNS: qr = QR(x0, x4, x8,  x12)
        x0 = qr[1]
        x4 = qr[10]
        x8  = qr[11]
        x12 = qr[100]
        qr = QR(x1, x5, x9,  x13)
        x1 = qr[1]
        x5 = qr[10]
        x9  = qr[11]
        x13 = qr[100]
        qr = QR(x2, x6, x10, x14)
        x2 = qr[1]
        x6 = qr[10]
        x10 = qr[11]
        x14 = qr[100]
        qr = QR(x3, x7, x11, x15)
        x3 = qr[1]
        x7 = qr[10]
        x11 = qr[11]
        x15 = qr[100]

        qr = QR(x0, x5, x10, x15)
        x0 = qr[1]
        x5 = qr[10]
        x10 = qr[11]
        x15 = qr[100]
        qr = QR(x1, x6, x11, x12)
        x1 = qr[1]
        x6 = qr[10]
        x11 = qr[11]
        x12 = qr[100]
        qr = QR(x2, x7, x8,  x13)
        x2 = qr[1]
        x7 = qr[10]
        x8  = qr[11]
        x13 = qr[100]
        qr = QR(x3, x4, x9,  x14)
        x3 = qr[1]
        x4 = qr[10]
        x9  = qr[11]
        x14 = qr[100]

        i = ADD(i, 1)
    }

    x0 = BAND( ADD(x0, CH_CONST0), MASK32 )
    x1 = BAND( ADD(x1, CH_CONST1), MASK32 )
    x2 = BAND( ADD(x2, CH_CONST2), MASK32 )
    x3 = BAND( ADD(x3, CH_CONST3), MASK32 )
    x4 = BAND( ADD(x4, ch_key0), MASK32 )
    x5 = BAND( ADD(x5, ch_key1), MASK32 )
    x6 = BAND( ADD(x6, ch_key2), MASK32 )
    x7 = BAND( ADD(x7, ch_key3), MASK32 )
    x8 = BAND( ADD(x8, ch_key4), MASK32 )
    x9 = BAND( ADD(x9, ch_key5), MASK32 )
    x10 = BAND( ADD(x10, ch_key6), MASK32 )
    x11 = BAND( ADD(x11, ch_key7), MASK32 )
    x12 = BAND( ADD(x12, ch_counter), MASK32 )
    x13 = BAND( ADD(x13, ch_nonce0), MASK32 )
    x14 = BAND( ADD(x14, ch_nonce1), MASK32 )
    x15 = BAND( ADD(x15, ch_nonce2), MASK32 )

    TNS: out = [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15]
    RETURN(out)
}

FUNC REFILL_BUF():INT{
    ch_buf = CHACHA_BLOCK()
    ch_buf_pos = 0
    ch_counter = BAND( ADD(ch_counter, 1), MASK32 )
    RETURN(0)
}

FUNC DERIVE_KEY_AND_NONCE(INT:seed):INT{
    INT: s = BAND(seed, MASK32)
    INT: i = 0
    WHILE( LT(i, 1000) ){  # 8 key words
        s = BAND( ADD( MUL(s, 01000001110001100100111001101101), 00000000000000000011000000111001 ), MASK32 )
        IF(EQ(i,0)){ ch_key0 = s }
        IF(EQ(i,1)){ ch_key1 = s }
        IF(EQ(i,10)){ ch_key2 = s }
        IF(EQ(i,11)){ ch_key3 = s }
        IF(EQ(i,100)){ ch_key4 = s }
        IF(EQ(i,101)){ ch_key5 = s }
        IF(EQ(i,110)){ ch_key6 = s }
        IF(EQ(i,111)){ ch_key7 = s }
        i = ADD(i, 1)
    }
    INT: j = 0
    WHILE( LT(j, 11) ){  # 3 nonce words
        s = BAND( ADD( MUL(s, 01000001110001100100111001101101), 00000000000000000011000000111001 ), MASK32 )
        IF(EQ(j,0)){ ch_nonce0 = s }
        IF(EQ(j,1)){ ch_nonce1 = s }
        IF(EQ(j,10)){ ch_nonce2 = s }
        j = ADD(j, 1)
    }
    RETURN(0)
}

FUNC CS_PRNG_SEED(INT:seed):INT{
    DERIVE_KEY_AND_NONCE(seed)
    ch_counter = 0
    ch_buf = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ch_buf_pos = 10000  # 16
    RETURN(ch_counter)
}

FUNC CS_PRNG_NEXT():INT{
    IF( GTE(ch_buf_pos, 10000) ){  # 16
        REFILL_BUF()
    }
    INT: v = ch_buf[ ADD(ch_buf_pos, 1) ]
    ch_buf_pos = ADD(ch_buf_pos, 1)
    RETURN(v)
}

FUNC CS_PRNG_RANGE(INT:max):INT{
    ASSERT( GT(max, 0) )
    RETURN( MOD(CS_PRNG_NEXT(), max) )
}

FUNC CS_PRNG_RANGE_MIN_MAX(INT:min, INT:max):INT{
    ASSERT( LTE(min, max) )
    INT: range = SUB(max, min)
    IF( EQ(range, 0) ){ RETURN(min) }
    ASSERT( GT(range, 0) )
    INT: offset = CS_PRNG_RANGE(range)
    RETURN( ADD(offset, min) )
}