#ChaCha20-based cryptographically secure pseudorandom number generator
IMPORT(collection)

MASK32 = SUB( POW(10,100000), 1 )  # 2^32-1

# ChaCha20 constants ("expand 32-byte k")
CH_CONST0 = 01100001011100000111000001100101
CH_CONST1 = 00110011001000000110010001101110
CH_CONST2 = 01111001011000100010110100110010
CH_CONST3 = 01101011001000000110010101110100

ch_key0 = 0
ch_key1 = 0
ch_key2 = 0
ch_key3 = 0
ch_key4 = 0
ch_key5 = 0
ch_key6 = 0
ch_key7 = 0
ch_nonce0 = 0
ch_nonce1 = 0
ch_nonce2 = 0
ch_counter = 0
ch_buf = collection.COL_EMPTY()
ch_buf_pos = 10000  # 16 -> force refill

FUNC ROTL32(x, n){
    x32 = BAND(x, MASK32)
    left = BAND( SHL(x32, n), MASK32 )
    right = DIV( x32, POW(10, SUB(100000, n)) )
    RETURN( BOR(left, right) )
}

FUNC QR(a, b, c, d){
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 10000 )   # 16
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 1100 )    # 12
    a = BAND( ADD(a, b), MASK32 )
    d = ROTL32( BXOR(d, a), 1000 )    # 8
    c = BAND( ADD(c, d), MASK32 )
    b = ROTL32( BXOR(b, c), 111 )     # 7
    coll = collection.COL_EMPTY()
    coll = collection.COL_PUSH(coll, a)
    coll = collection.COL_PUSH(coll, b)
    coll = collection.COL_PUSH(coll, c)
    coll = collection.COL_PUSH(coll, d)
    RETURN(coll)
}

FUNC CHACHA_BLOCK(){
    x0 = CH_CONST0
    x1 = CH_CONST1
    x2 = CH_CONST2
    x3 = CH_CONST3
    x4 = ch_key0
    x5 = ch_key1
    x6 = ch_key2
    x7 = ch_key3
    x8 = ch_key4
    x9 = ch_key5
    x10 = ch_key6
    x11 = ch_key7
    x12 = ch_counter
    x13 = ch_nonce0
    x14 = ch_nonce1
    x15 = ch_nonce2
    i = 0
    WHILE( LT(i, 1010) ){  # 10 double-rounds
        qr = QR(x0, x4, x8,  x12)
        x0 = collection.COL_GET(qr,0)
        x4 = collection.COL_GET(qr,1)
        x8  = collection.COL_GET(qr,10)
        x12 = collection.COL_GET(qr,11)
        qr = QR(x1, x5, x9,  x13)
        x1 = collection.COL_GET(qr,0)
        x5 = collection.COL_GET(qr,1)
        x9  = collection.COL_GET(qr,10)
        x13 = collection.COL_GET(qr,11)
        qr = QR(x2, x6, x10, x14)
        x2 = collection.COL_GET(qr,0)
        x6 = collection.COL_GET(qr,1)
        x10 = collection.COL_GET(qr,10)
        x14 = collection.COL_GET(qr,11)
        qr = QR(x3, x7, x11, x15)
        x3 = collection.COL_GET(qr,0)
        x7 = collection.COL_GET(qr,1)
        x11 = collection.COL_GET(qr,10)
        x15 = collection.COL_GET(qr,11)

        qr = QR(x0, x5, x10, x15)
        x0 = collection.COL_GET(qr,0)
        x5 = collection.COL_GET(qr,1)
        x10 = collection.COL_GET(qr,10)
        x15 = collection.COL_GET(qr,11)
        qr = QR(x1, x6, x11, x12)
        x1 = collection.COL_GET(qr,0)
        x6 = collection.COL_GET(qr,1)
        x11 = collection.COL_GET(qr,10)
        x12 = collection.COL_GET(qr,11)
        qr = QR(x2, x7, x8,  x13)
        x2 = collection.COL_GET(qr,0)
        x7 = collection.COL_GET(qr,1)
        x8  = collection.COL_GET(qr,10)
        x13 = collection.COL_GET(qr,11)
        qr = QR(x3, x4, x9,  x14)
        x3 = collection.COL_GET(qr,0)
        x4 = collection.COL_GET(qr,1)
        x9  = collection.COL_GET(qr,10)
        x14 = collection.COL_GET(qr,11)

        i = ADD(i, 1)
    }

    x0 = BAND( ADD(x0, CH_CONST0), MASK32 )
    x1 = BAND( ADD(x1, CH_CONST1), MASK32 )
    x2 = BAND( ADD(x2, CH_CONST2), MASK32 )
    x3 = BAND( ADD(x3, CH_CONST3), MASK32 )
    x4 = BAND( ADD(x4, ch_key0), MASK32 )
    x5 = BAND( ADD(x5, ch_key1), MASK32 )
    x6 = BAND( ADD(x6, ch_key2), MASK32 )
    x7 = BAND( ADD(x7, ch_key3), MASK32 )
    x8 = BAND( ADD(x8, ch_key4), MASK32 )
    x9 = BAND( ADD(x9, ch_key5), MASK32 )
    x10 = BAND( ADD(x10, ch_key6), MASK32 )
    x11 = BAND( ADD(x11, ch_key7), MASK32 )
    x12 = BAND( ADD(x12, ch_counter), MASK32 )
    x13 = BAND( ADD(x13, ch_nonce0), MASK32 )
    x14 = BAND( ADD(x14, ch_nonce1), MASK32 )
    x15 = BAND( ADD(x15, ch_nonce2), MASK32 )

    out = collection.COL_EMPTY()
    out = collection.COL_PUSH(out, x0)
    out = collection.COL_PUSH(out, x1)
    out = collection.COL_PUSH(out, x2)
    out = collection.COL_PUSH(out, x3)
    out = collection.COL_PUSH(out, x4)
    out = collection.COL_PUSH(out, x5)
    out = collection.COL_PUSH(out, x6)
    out = collection.COL_PUSH(out, x7)
    out = collection.COL_PUSH(out, x8)
    out = collection.COL_PUSH(out, x9)
    out = collection.COL_PUSH(out, x10)
    out = collection.COL_PUSH(out, x11)
    out = collection.COL_PUSH(out, x12)
    out = collection.COL_PUSH(out, x13)
    out = collection.COL_PUSH(out, x14)
    out = collection.COL_PUSH(out, x15)
    RETURN(out)
}

FUNC REFILL_BUF(){
    ch_buf = CHACHA_BLOCK()
    ch_buf_pos = 0
    ch_counter = BAND( ADD(ch_counter, 1), MASK32 )
    RETURN(0)
}

FUNC DERIVE_KEY_AND_NONCE(seed){
    s = BAND(seed, MASK32)
    i = 0
    WHILE( LT(i, 1000) ){  # 8 key words
        s = BAND( ADD( MUL(s, 01000001110001100100111001101101), 00000000000000000011000000111001 ), MASK32 )
        IF(EQ(i,0)){ ch_key0 = s }
        IF(EQ(i,1)){ ch_key1 = s }
        IF(EQ(i,10)){ ch_key2 = s }
        IF(EQ(i,11)){ ch_key3 = s }
        IF(EQ(i,100)){ ch_key4 = s }
        IF(EQ(i,101)){ ch_key5 = s }
        IF(EQ(i,110)){ ch_key6 = s }
        IF(EQ(i,111)){ ch_key7 = s }
        i = ADD(i, 1)
    }
    j = 0
    WHILE( LT(j, 11) ){  # 3 nonce words
        s = BAND( ADD( MUL(s, 01000001110001100100111001101101), 00000000000000000011000000111001 ), MASK32 )
        IF(EQ(j,0)){ ch_nonce0 = s }
        IF(EQ(j,1)){ ch_nonce1 = s }
        IF(EQ(j,10)){ ch_nonce2 = s }
        j = ADD(j, 1)
    }
    RETURN(0)
}

FUNC CS_PRNG_SEED(seed){
    DERIVE_KEY_AND_NONCE(seed)
    ch_counter = 0
    ch_buf = collection.COL_EMPTY()
    ch_buf_pos = 10000  # 16
    RETURN(ch_counter)
}

FUNC CS_PRNG_NEXT(){
    IF( GTE(ch_buf_pos, 10000) ){  # 16
        REFILL_BUF()
    }
    v = collection.COL_GET(ch_buf, ch_buf_pos)
    ch_buf_pos = ADD(ch_buf_pos, 1)
    RETURN(v)
}

FUNC CS_PRNG_RANGE(max){
    ASSERT( GT(max, 0) )
    RETURN( MOD(CS_PRNG_NEXT(), max) )
}

FUNC CS_PRNG_RANGE_MIN_MAX(min, max){
    ASSERT( LTE(min, max) )
    range = SUB(max, min)
    IF( EQ(range, 0) ){ RETURN(min) }
    ASSERT( GT(range, 0) )
    offset = CS_PRNG_RANGE(range)
    RETURN( ADD(offset, min) )
}