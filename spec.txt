Abstract State Machine Language Specification
==============================================

This document specifies an imperative programming language with a binary
integer data model and an explicit small-step execution semantics. A program
is compiled into an initial machine state (a seed configuration) and then
executed solely by repeatedly applying a fixed, program-independent
state-transition (rewrite) function. All intermediate states are
(semi-)human-readable and serializable, and execution can be traced and
replayed exactly, including I/O and nondeterministic choices, which are modeled
explicitly for deterministic replay.

1. Overview
-----------

The language is a familiar statement-based, imperative language. Programs
consist of variable declarations via assignment, expressions, and
control-flow constructs such as 'IF', 'ELSIF', 'ELSE', 'WHILE', and 'FOR'.
ASM-Lang now has two runtime data types: binary integers and strings.
Identifiers, function parameters, and return values are statically typed;
the type of every symbol must be declared when it is first introduced.
Computation proceeds by evaluating expressions and executing statements in
sequence, with explicit constructs for branching and looping. Input and
output are modeled through built-in operators, in particular 'INPUT' and
'PRINT'.

The interpreter compiles source code into a single initial configuration (the
seed state), which includes the program code, an empty variable environment,
and an initial I/O history. It then advances execution by repeatedly applying
a single, fixed small-step transition function that is independent of the
particular program. A disassembler and log view expose all intermediate
states so that every step and every control-flow decision is inspectable and
replay-able.


2. Lexical Structure
--------------------

Source files are sequences of ASCII characters. Non-ASCII characters are not
permitted in syntactic elements that enter the program namespace, such as
identifiers.

Whitespace consists of the space character ('U+0020'), horizontal tab,
carriage return, and line feed. It may appear freely between tokens and is
otherwise ignored, except that newlines delimit top-level statements (see
Section 5.1).

A comment begins with the '#' character and continues to the end of the
current line. Comments have no effect on execution.

The program text is divided into several token kinds: binary integer
literals (Section 3.1); string literals delimited by double quotation marks
('"', Section 3.2); identifiers for variable names and user-defined
function names (Section 2.5); keywords and built-ins (control-flow
keywords, built-in operators and functions; see Sections 4 and 5); and
delimiters, namely '(', ')', '[', ']', '{', '}', ',', ':', and '='.

Keywords: The language's reserved keywords (for example, 'IF', 'WHILE',
'FUNC', etc.) are matched by the lexer exactly as listed in this
specification and are case-sensitive. Programs must use the keywords in
their canonical uppercase form; otherwise the token will be recognized as
an identifier. Built-in operator names such as 'INPUT', 'PRINT', and
'IMPORT' follow the same case-sensitive matching rules.

Line continuation: The character '^' serves as a line-continuation marker.
When a caret '^' appears in the source and is followed immediately by a
newline, both the '^' and the newline are ignored by the lexer (that is,
the logical line continues on the next physical line). If a caret appears
and is not immediately followed by a newline (or the platform's
single-character newline sequence), the lexer must raise a syntax error.

The character '-' is not an operator token. It is permitted only as the
leading sign of a binary integer literal (Section 3.1). If '-' appears
anywhere else, the lexer must raise a syntax error. When '-' starts a
literal, any spaces, horizontal tabs, or carriage returns between the '-'
and the first digit are ignored and the literal is treated as negative.

Identifiers denote variables and user-defined functions. They must be
non-empty and case-sensitive. An identifier must not contain non-ASCII
characters, nor any of the following characters: '{', '}', '[', ']', '(',
')', '=', ',', '#'. The first character of an identifier must not be the
digit '0' or '1' (these digits are used to begin binary integer literals).
However, the characters '0' and '1' are permitted in subsequent positions
within an identifier (for example, `a01` and `X10Y` are valid identifiers,
while `0foo` and `1bar` are not). The namespace is flat: variables and
functions share a single identifier space, so a given name cannot
simultaneously denote both. A user-defined function name must not conflict
with the name of any built-in operator or function (see Section 4.1).

Identifier character set (clarification): The (non-empty) sequence of
characters that forms an identifier is determined by the following rules,
which match the reference lexer implementation:

- The first character MUST NOT be '0' or '1'. Any other non-ASCII
  character is disallowed, but otherwise the lexer permits a broad set of
  ASCII punctuation and symbol characters in addition to letters and
  digits. In particular, the following characters are valid as the first
  character of an identifier:

  - Lowercase letters 'a'–'z'
  - Uppercase letters 'A'–'Z'
  - Decimal digits '2'–'9'
  - The punctuation and symbol characters
    `; / ! @ $ % & ~ _ + | < > ?`

- Subsequent characters in an identifier may be any of the following:

  - Lowercase letters 'a'–'z'
  - Uppercase letters 'A'–'Z'
  - Decimal digits '0'–'9'
  - The punctuation and symbol characters
    `; . / ! @ $ % & ~ _ + | < > ?`

  As noted above, non-ASCII characters remain disallowed, and the
  delimiter characters '{', '}', '[', ']', '(', ')', '=', ',', and '#'
  are never permitted inside identifiers.

This deliberately-permissive identifier character set preserves an
unambiguous lexical distinction between binary integer literals (which
must begin with '0' or '1') and identifiers, while allowing module-
qualified names and other symbolic conventions to be expressed directly
as plain identifiers in source code.


3. Data Model
-------------

ASM-Lang supports two literal data types: binary integers and strings.

Binary integer literal: an unsigned non-empty sequence of '{0,1}' (for
example, '0', '1', '1011'), or a signed literal formed by a leading '-' (the
dash is part of the literal, not an operator) followed by optional spaces,
tabs, or carriage returns and then a non-empty sequence of '{0,1}'. A '-'
that does not immediately introduce a literal is a syntax error.

String literal: a sequence of ASCII characters enclosed in double quotation
marks '"' with no escape processing. Newlines are not permitted inside string
literals. The literal's value is the contained character sequence.

Every runtime value has a static type: INT or STR. Integers are
conceptually unbounded mathematical integers. Strings are byte strings of
ASCII characters. Operations that would otherwise produce non-integer
results are defined with explicit rounding behaviour (see Section 4.2) and
operate only on INT values. When a Boolean interpretation is required,
integers treat 0 as false and non-zero as true. For Boolean operators that
accept strings (Section 4), an empty string is false and any non-empty string
is true unless otherwise specified. Control-flow conditions ('IF', 'ELSIF',
'WHILE') and 'ASSERT' convert strings to integers using the same rules as the
'INT' built-in: if the string is empty, it converts to 0; if it consists only
of '0' and '1', it converts to the corresponding binary integer; otherwise it
converts to 1.


4. Expressions and Operators
----------------------------

All operators and functions, both built-in and user-defined, share a uniform
function-call style syntax of the form 'NAME(arg1, arg2, ..., argN)'. The
argument list may be empty for certain functions such as 'INPUT'. Arguments
are separated by commas, and spaces may appear around commas and inside
parentheses without changing meaning. Each operator has either a fixed or a
variable arity as described below.

All built-ins operate on typed values and, unless explicitly stated
otherwise, return an integer result. Unless explicitly noted, any
multi-argument operator requires at least one argument.

Integer-only operators: the following accept only INT arguments and return an
INT. Supplying a STR raises a runtime error: ADD, SUB, MUL, DIV, CDIV, POW,
MOD, NEG, ABS, GCD, LCM, BAND, BOR, BXOR, BNOT, SHL, SHR, GT, LT, GTE, LTE,
SUM, PROD, LOG, and CLOG. Their semantics match the previous integer-only
definition (for example, DIV is floor division, POW requires a non-negative
exponent, SHL/SHR require non-negative shift counts, etc.).

Mixed-type operators (INT or STR):
- LEN(a1, ..., aN) returns the number of supplied arguments (an INT) and does
  not inspect the argument types.
- AND, OR, XOR, NOT, ALL, ANY treat INT values as usual (0 is false, non-zero
  is true) and treat STR values as false when empty and true when non-empty.
  These operators always return an INT 0 or 1.
- EQ(a, b) returns 1 when both arguments have the same type and equal
  contents, else 0. When types differ, the result is 0 without coercion.
- SLICE(a, hi, lo) requires 'hi' and 'lo' to be INT. If 'a' is INT, it returns
  the inclusive bit-slice [hi:lo] as before (bit 0 is the least-significant
  bit). If 'a' is STR, it returns the inclusive character slice from index
  'hi' down to 'lo' counting from the right (index 0 is the last character);
  indices must be non-negative and within the string.
- MAX / MIN: when all arguments are INT they return the numeric max/min. When
  all arguments are STR they return the longest/shortest string (ties are
  implementation-defined). Mixing INT and STR is a runtime error.
- JOIN: when all arguments are INT it concatenates binary spellings with the
  same sign rule as before (all non-negative or all negative). When all
  arguments are STR it concatenates the strings. Mixing INT and STR is a
  runtime error.

Conversion operators:
- INT(s) converts a STR to INT: empty string -> 0; strings containing only
  '0' and '1' -> the corresponding binary integer; any other non-empty string
  -> 1. Passing an INT returns it unchanged.
- STR(n) converts an INT to its binary spelling as a STR (including a leading
  '-' for negative integers). Passing a STR returns it unchanged.

Input, output, and assertions:
- INPUT() returns a STR containing the raw input line (no implicit numeric
  conversion). The I/O event is recorded for replay.
- PRINT(a1, ..., aN) accepts INT or STR. INT arguments are rendered in binary
  (with '-' for negatives); STR arguments are emitted as-is. The return value
  is INT 0.
- ASSERT(a) interprets its argument using the INT conversion rules for
  conditions (empty string -> 0, binary string -> integer value, other
  non-empty string -> 1). If the result is 0, execution halts with an
  assertion failure.

Other operators (unchanged): IMPORT, MAIN, DEL, EXIST, and EXIT retain their
previous meanings but now operate in a typed environment.

'IMPORT(name)' loads and executes another source file as a distinct module
namespace. The argument must be an identifier naming a module; the
interpreter first looks for a file named '<name>.asmln' in the same
directory as the current source file. When the current source is provided
via the '-source' string literal mode, the primary search directory is the
process's current working directory. If the module file is not found in
that location, the interpreter will additionally attempt to load the file
from a `lib` subdirectory located alongside the interpreter implementation
(that is, '<interpreter_dir>/lib/<name>.asmln', where '<interpreter_dir>' is
the directory containing the interpreter script or executable).

The imported file is parsed and executed in its own isolated top-level
environment: top-level assignments and function definitions in the imported
module do not directly mutate the caller's environment. During execution
inside the imported module, unqualified identifiers (for example, `x` or
`helper`) refer to names in the module's own top-level namespace. Qualified
identifiers (for example, `other.FOO`) refer only to the dotted names that
the module itself has created or imported; in other words, a module may
refer to its own imports via qualified names, and those qualified bindings
are scoped to that module's namespace.

After the module finishes executing, each top-level binding exported by the
module is made available to the importer under a dotted name formed by the
module identifier and the exported symbol, for example `module.FOO` or
`module.bar`. If the imported module itself imported other modules, those
nested qualified bindings are preserved under the importing module's
namespace (for example, `module.other.SYM` denotes a symbol that `module`
imported from `other`). Callers must reference imported symbols using the
qualified form (for example: `IMPORT(module)` followed by `module.FOO()`),
which preserves a clear separation of namespaces between modules.

Each 'IMPORT' call executes the target module anew and then publishes its
top-level bindings under the dotted module namespace in the caller's
environment; there is no automatic caching or cycle detection. Importantly,
IMPORT does not modify or remove the original bindings of modules that the
imported module relied upon; instead, nested qualified names are exposed
under the importer as dotted names rooted at the imported module's
identifier.

'INPUT()' (or simply 'INPUT' in expression position) reads a value from the
console or input stream. If the incoming text is empty, the result is '0'.
If the text consists solely of the characters '0' and '1', it is interpreted
as the corresponding binary integer. Any other non-empty text yields the
result '1'. All I/O events, including inputs, are recorded in the execution
log for deterministic replay.

'ASSERT(a)' checks that its argument is true in the Boolean sense. If 'a' is
non-zero, execution proceeds normally; if 'a' is '0', the program crashes
with an assertion failure.

'MAIN()' returns '1' when the call site belongs to the primary program file
(the file passed as the interpreter's first argument, or '<string>' when
'-source' is used). It returns '0' when executed from code that came from an
'IMPORT' (including nested imports). The result is determined solely by the
source file that contains the call expression, not by the caller's call stack.

Program termination is exposed via 'EXIT'. 'EXIT()' or 'EXIT(code)' requests
immediate termination of the interpreter. If an integer 'code' is supplied,
it is used as the interpreter's process exit code; otherwise '0' is used.
Execution stops immediately when 'EXIT' is executed (no further statements
run), and an entry is recorded in the state log to make deterministic replay
possible. Using 'EXIT' inside a function terminates the entire program (not
just the function).

Memory-management and function-return behavior are also exposed via
operators. 'DEL(x)' deletes the variable 'x' from the current environment,
freeing its memory; any subsequent reference to 'x' is an error unless 'x'
is re-assigned. 'RETURN(a)', when executed inside a function body,
immediately terminates that function and returns the value of 'a' to the
caller. Executing 'RETURN' outside of a function is a runtime error.


5. Statements and Control Flow
------------------------------

A program consists of zero or more statements separated by newlines. Each
top-level expression or assignment must appear on its own line. The basic
statement forms are assignments of the form 'identifier = expression',
expression statements such as calls to 'PRINT' whose result is ignored,
control-flow constructs ('IF', 'ELSIF', 'ELSE', 'WHILE', and 'FOR'), and
function definitions ('FUNC' declarations; see Section 6).

Blocks group one or more statements and are enclosed in either square or
curly brackets: '[ statement1 ... statementN ]' or
'{ statement1 ... statementN }'. The two bracket styles are equivalent but
must match (that is, '[' closes with ']' and '{' closes with '}'). Blocks
serve as the bodies of control-flow constructs and functions.

Assignments have the syntax 'TYPE : identifier = expression' on first use,
where TYPE is 'INT' or 'STR'. Spaces around the colon and equals sign are
optional. Subsequent assignments to an existing identifier may omit the type
but must preserve the original type. Variables are deallocated only when
'DEL(identifier)' is executed.

The language provides 'IF', 'ELSIF', and 'ELSE' constructs for conditional
execution. An 'IF' statement has the general form 'IF(condition)[ block ]' or
'IF(condition){ block }'. Optional chained branches may follow: one or more
'ELSIF(condition)[ block ]' or 'ELSIF(condition){ block }' clauses and an
optional terminal 'ELSE[ block ]' or 'ELSE{ block }' clause. An 'ELSIF' or
'ELSE' must immediately follow an 'IF' or another 'ELSIF'; otherwise it is a
syntax error. At most one 'ELSE' may appear in a given chain. Evaluation
proceeds by first evaluating the condition of the initial 'IF'. If it is
non-zero, the associated block executes and the rest of the chain is
skipped. Otherwise, the conditions of subsequent 'ELSIF' clauses are
evaluated in order until one is non-zero; its block then executes and the
chain terminates. If no 'IF' or 'ELSIF' condition is satisfied and an
'ELSE' is present, the 'ELSE' block executes; if there is no 'ELSE', no block
in the chain executes.
Conditions accept INT or STR. STR conditions are first converted to INT using
the 'INT' built-in rules (empty -> 0; binary string -> that integer; other
non-empty -> 1) before truthiness is checked.

Loops are provided via 'WHILE' and 'FOR'. A 'WHILE' loop has the form
'WHILE(condition)[ block ]' or 'WHILE(condition){ block }'. On each
iteration, the condition is evaluated; if it is non-zero, the block executes
and control returns to the start of the loop to evaluate the condition
again. If the condition evaluates to zero, the loop terminates and execution
continues with the next statement.

The 'FOR' construct has the form 'FOR(counter, target)[ block ]' or
'FOR(counter, target){ block }', where 'counter' is an identifier and
'target' is an expression. At loop entry, 'target' is evaluated once to a
value 'T' (must be INT), and 'counter' is initialized to the INT value '0',
creating it as an INT if necessary.
The loop then repeats: if the current value of 'counter' is greater than or
equal to 'T', the loop exits; otherwise, the block executes and 'counter' is
incremented by '1' before the next iteration.

BREAK statement: The language provides a statement form 'BREAK(n)'
that terminates enclosing loops. When executed inside a loop body
(either a 'WHILE' or 'FOR' loop), 'BREAK(n)' breaks out of the
innermost 'n' loops and resumes execution at the statement following
those loops. The argument 'n' is evaluated as an integer at runtime and
must be strictly positive. If 'n ≤ 0' the interpreter raises a runtime
error. If 'n' is greater than the number of currently-enclosing loops
(that is, the statement would escape all surrounding loops), the
interpreter raises a runtime error rather than silently terminating the
program. Using 'BREAK' outside of any loop context similarly results in
an error. The exact error type and reporting information are
implementation-defined but should be recorded in the state log to make
replay and debugging deterministic.

CONTINUE statement: The language provides a statement form 'CONTINUE()'
that, when executed inside a loop body (either a 'WHILE' or 'FOR' loop),
immediately proceeds to the next iteration of the innermost enclosing
loop, skipping any remaining statements in the current iteration. If
the current iteration is the final one (that is, no further iterations
would occur), 'CONTINUE()' has the same effect as executing
'BREAK(1)' and thus exits the innermost loop. Using 'CONTINUE()' outside
of any loop context is a runtime error. Implementations should record
the use of 'CONTINUE' in the state log so that replay and tracebacks
remain deterministic.


6. Functions
------------

Functions are defined using the 'FUNC' keyword with explicit parameter and
return types. The canonical form is
 'FUNC name(T1:arg1, T2:arg2, ..., TN:argN):R[ block ]' or
 'FUNC name(T1:arg1, ..., TN:argN):R{ block }', where each 'Tk' and 'R' is
 either 'INT' or 'STR'. Defining a function binds 'name' to a callable body
 with the specified typed formal parameters. Function names must not
 conflict with the names of built-in operators or functions.

A user-defined function is called with the same syntax as a built-in:
'name(expr1, expr2, ..., exprN)'. Arguments are evaluated left-to-right and
must match the declared parameter types exactly; type mismatches raise a
runtime error. The function body executes in a new environment (activation
record) that closes over the defining environment. If a 'RETURN(v)'
statement is executed, the function terminates immediately and yields 'v';
the returned value must match the declared return type. If control reaches
the end of the body without 'RETURN', the function returns a default value
of the declared return type (0 for INT, "" for STR).

Built-in operators and functions can be viewed as pre-defined functions
provided by the runtime environment. User-defined functions share the same
call syntax and are distinguished only by their names and bodies. Because of
the shared namespace, a user-defined function is not permitted to use any name
already reserved for a built-in. Attempting to violate this will raise an
exception.


7. Variables and Memory Model
-----------------------------

A variable is created only when it is first assigned with an explicit type
annotation of the form 'TYPE : name = expression', where TYPE is 'INT' or
'STR'. For example: 'INT: counter = 0' or 'STR : message = "hi"'. Subsequent
assignments to the same name must match the declared type and may omit the
type annotation ('counter = ADD(counter,1)'). Assigning to an undeclared name
without a type annotation is a runtime error. A variable exists until
'DEL(name)' is executed. Referencing a variable that has never been declared,
or that has been deleted, is a runtime error.

The language assumes at least a global typed environment mapping identifiers
to (type, value) pairs. Function calls create new environments for parameters
and local variables, as described in Section 6.2; the precise details of name
resolution depend on the chosen scoping rules.


8. Execution Model and Semantics
--------------------------------

The interpreter compiles the source program into an initial machine state,
called the seed configuration. This configuration contains at least the
parsed (and possibly transformed) program representation, the initial
variable environments such as an empty global environment, and an explicit
model of I/O and nondeterministic inputs, initially empty.

Execution is driven by a single, fixed, program-independent small-step
state-transition function 'step'. At each step, 'step' takes the current
state and produces the next one, encompassing expression evaluation,
statement execution, function call and return, and I/O events.

Every state produced during execution is serializable and human-readable.
The interpreter maintains a disassembler and log that record the sequence of
states visited, the program locations and conditions involved in each
control-flow decision, and all I/O actions with their corresponding values.
Because I/O and nondeterminism are modeled explicitly within the state, the
execution of any program can be deterministically replayed from its seed
configuration together with the recorded inputs.


9. Standard Library
----------

The standard library is a group of modules for common use cases distributed
with the interpreter.
It includes modules for:
- Collections: indexed lists of integers with efficient encoding and decoding.
- CSPRNG: Cryptographically secure (ChaCha20) pseudorandom number generation
  with seed management.
- Encryption: AES-GCM and RSA-OAEP encryption and decryption utilities.
- Hashes: SHA-256 hashing.
- Prime: primality testing and prime number generation, along with
  factorization and other common prime utilities.
- PRNG: Fast (LCG) pseudorandom number generation with seed management.

10. Tracebacks and Error Reporting

When a runtime error or exception occurs the interpreter must produce a
deterministic, human-readable traceback derived from the state log. The
traceback exposes the call stack (frames) at the point of failure and
associates each frame with both (1) a compact source-location description
and (2) the relevant serialized state sections and state-transformation
records from the state log. The goal is to provide developers with the
same immediate debugging information that Python's traceback provides but
with the additional ability to inspect the exact machine states and the
rewrite steps that led to the error for deterministic replay.

10.1 Traceback semantics (high level)


GOTOPOINT and GOTO: Two additional control-flow primitives allow program
execution to jump to a dynamically-registered program location. The
statement form 'GOTOPOINT(n)' evaluates the expression 'n' and registers a
gotopoint with that identifier at the point where the statement executes.
Registration occurs at runtime when the 'GOTOPOINT' statement executes;
subsequent execution (including execution within loops or after imports) may
depend on whether the gotopoint has been registered. Identifiers may be INT
or STR; negative INT identifiers are invalid.

The statement form 'GOTO(n)' evaluates 'n' at runtime and transfers
execution to the previously-registered gotopoint whose identifier equals
'n', matching both type and value. If no gotopoint with that identifier has
been registered in a scope visible to the jump target, the interpreter raises
a runtime error. GOTO may jump forward or backward relative to the target
gotopoint; jumping to an unregistered identifier is an error. Gotopoints are
not restricted to a single lexical block: they are visible across the
containing function (or top-level program scope) in which they are defined.
Implementations may choose to expose an even broader scope (for example,
process-wide), but by default gotopoints registered within a function or at
top-level are available to any GOTO executed within the same function or
top-level code. This change enables cross-block jumps while preserving a
clear containment model: a GOTO cannot target a gotopoint defined in an
unrelated function or module unless the implementation explicitly exposes
that mapping.

GOTO and GOTOPOINT are intended to be low-level primitives and their use
can make programs harder to reason about. They are serialized in the state
log like other statements so that execution is fully replayable for
debugging and tracing.
- Trigger: a traceback is produced when a runtime error occurs that
  prevents normal forward execution (e.g., an assertion failure, divide
  by zero, undefined variable reference, executing 'RETURN' outside of a
  function, or any other interpreter-defined runtime error).
- Content: the traceback must list frames in chronological call order
  from the outermost (earliest) frame to the innermost (where the
  error occurred), and for each frame include: function name (or
  '<top-level>' for global code), precise source location, a short
  excerpt of the offending statement, and identifiers linking to the
  corresponding states in the state log.
- State linkage: every frame must reference at least one serialized
  state snapshot from the state log that corresponds to the machine
  configuration immediately before the failing rewrite step for that
  frame. The innermost frame must also reference the rewrite (transition)
  record that produced the error (that is, the failing step).
- Presentation modes: the interpreter must support a concise textual
  traceback (default) and a verbose mode. The concise mode shows the
  usual file/line/function stack with a one-line code excerpt per
  frame and the state-log index. The verbose mode prints, for each
  frame, the selected state sections (for example: local environment,
  selected global variables, and the expression evaluation stack) and
  the full state-transformation record (from_state -> to_state, the
  rewrite rule name and arguments). The verbose mode is intended for
  interactive debugging and post-mortem inspection.

10.2 Required fields and invariants in the state log

To make tracebacks precise and implementable, the state log (and the
machine state representation) must include the following information at
every step when relevant:

- 'step_index' (integer): monotonically increasing index of the rewrite
  step in the state log.
- 'state_id' (opaque string or integer): stable identifier for the
  serialized machine state (seed, intermediate, or terminal).
- 'source_location' (optional): when a rewrite step is associated with a
  program location, include a 'source_location' record with at least the
  following fields: 'file' (string), 'line' (integer), and 'statement'
  (string containing the top-level statement text or canonical snippet).
- 'frame_id' (when present): identifier for the active call-frame in
  that state; frames must be addressable and referable by the traceback
  generator.
- 'env_snapshot' (selectable): a serialized partial view of the state
  containing bindings for the local variables of the active frame and,
  where reasonable, a subset of global variables. The interpreter may
  elide large or sensitive values by policy, but must provide a clear
  indication when values are elided.
- 'rewrite_record': for each step that performs a state transition, the
  log must include a record describing the rewrite rule (name, inputs,
  and parameters), and the 'from_state_id' and 'to_state_id' pairs.

10.3 Traceback textual format (recommended)

The following format is recommended for the concise textual traceback:

Traceback (most recent call last):
  File "<file>", line <line>, in <function_or_<top-level>>
    <statement excerpt>
    State log index: <step_index>  State id: <state_id>

The final (innermost) frame is then followed by a short error message
that includes the failing rewrite (for example: 'DivisionByZero'), the
rewrite rule name and the 'step_index' at which it failed. In verbose
mode, each frame block is followed by a labelled 'State snapshot:' and a
'State transformation:' section that contain the serialized 'env_snapshot'
and the 'rewrite_record' (including 'from_state_id' and 'to_state_id') so
that the failure can be reproduced by replaying the states and the
associated inputs.

10.4 Machine-readable traceback (JSON)

The interpreter must also be able to emit a machine-readable traceback
structure suitable for diagnostics tools and editors. A suggested JSON
schema is:

{
  "error": {
    "type": "DivisionByZero",
    "message": "Divide by zero in DIV(foo, 0)",
    "failing_step_index": 123
  },
  "traceback": [
    {
      "frame_index": 0,
      "name": "<top-level>",
      "source_location": {"file": "prog.asmln", "line": 12, "statement": "foo = INPUT"},
      "state_id": "s_0003",
      "step_index": 42,
      "env_snapshot": {"foo": 5, "bar": 10}
    },
    {
      "frame_index": 1,
      "name": "compute",
      "source_location": {"file": "lib.asmln", "line": 88, "statement": "DIV(a, b)"},
      "state_id": "s_0123",
      "step_index": 123,
      "env_snapshot": {"a": 17, "b": 0},
      "rewrite_record": {"rule": "DIV", "from_state_id": "s_0122", "to_state_id": "s_0123", "args": [17, 0]}
    }
  ]
}

The schema above is a guideline; implementations may extend it with
additional fields (for example, a Bitwise XOR between 'from_state' and
'to_state', or full serialized states). The only requirement is that a
consumer of the state log can identify which state and which rewrite
step correspond to each frame.

10.5 Point of origin in source code

The trace must clearly identify the point of origin (the expression or
statement that directly caused the error) by including the 'source_location'
and the 'step_index' of the failing rewrite. Implementations should also
include the exact token or sub-expression when available (for example,
the 'DIV(a,0)' call that produced the division-by-zero), and the
surrounding source excerpt (at least one line above and below, if
available) to make diagnosis easier.

10.6 Integrating tracebacks with the disassembler and replay

- The disassembler view must support jumping from a printed traceback to
  the corresponding state-log entry ('step_index') and to the
  reconstructed source location so that a user can inspect the full
  'from_state' and 'to_state' pair and step through the rewrite that
  produced the error.
- Because the state log records I/O and nondeterminism explicitly, the
  disassembler/replayer must be able to replay the exact failing step
  when given the seed configuration and the recorded inputs.

10.7 Implementation notes for builders

- The instrumentation needed for tracebacks is primarily bookkeeping:
  ensure the state log records 'step_index', 'state_id', 'frame_id', and
  optional 'source_location' for each step when appropriate.
- When collecting 'env_snapshot' data, prefer including only the local
  environment of the active frame and a small set of globals to keep
  tracebacks readable; provide a '--verbose' or similar flag to emit
  full snapshots.
- Security note: because state snapshots may contain sensitive data,
  implementations should provide a configurable policy to redact or
  obfuscate values when generating tracebacks for untrusted logs.

10.8 Example (concise textual traceback)

Traceback (most recent call last):
  File "prog.asmln", line 21, in <top-level>
    result = compute(foo, bar)
    State log index: 121  State id: s_0121
  File "lib.asmln", line 88, in compute
    x = DIV(a, b)
    State log index: 123  State id: s_0123
DivisionByZero: attempted to DIV by zero at step_index=123 (rewrite: DIV)

This example shows the outer call at the program top-level and the
innermost failing call in 'compute'. A verbose report would additionally
print the 'env_snapshot' for 'compute' showing 'a: 17, b: 0' and the
full 'rewrite_record' describing the DIV operation that failed.

  11. Interpreter Use
  -------------------

  This section documents how the reference interpreter accepts program input
  and how to enable verbose tracebacks that include environment snapshots.

  - Invocation arguments: the interpreter reads its first program argument
    (that is, 'argv[1]') as the program source. If the '-source' flag is not
    present, 'argv[1]' is interpreted as a path to a source file and the
    interpreter loads and parses that file. If the '-source' flag is present,
    'argv[1]' is treated as the source text itself (a string containing the
    program) and is parsed directly without reading a file.

  - Verbose tracebacks: if the '-verbose' flag is supplied on the command
    line, tracebacks include the environment snapshots described in
    Section 10.8. In concise traceback mode the '-verbose' flag causes the
    interpreter to attach an 'env_snapshot' entry to each frame shown; in
    verbose traceback mode the same flag expands the printed 'State snapshot:'
    blocks to include the selected local environment and any small set of
    globals included by policy. The snapshot contents follow the requirements
    in Section 10.2 and are suitable for deterministic replay.

  Notes:
  - The interpreter may support additional flags and a different ordering of
    arguments; the rules above define the semantics for 'argv[1]', '-source',
    and '-verbose' specifically and are intended to be stable for tooling and
    replay purposes.

  Example invocations (illustrative):
  - File mode: 'interpreter program.asm'
  - Source-string mode: 'interpreter -source "foo = INPUT\nPRINT(foo)"
    -verbose'

  - REPL / Interactive mode: 'interpreter' (no program argument)

REPL (Interactive Mode)
-----------------------

When the interpreter is invoked without a program path or a '-source' string
argument it enters an interactive read–eval–print loop (REPL). The REPL is a
convenient development and exploration environment that executes ASM-Lang
statements using the same parser, runtime, built-ins, and state-logging
semantics as file-mode execution. The following rules describe REPL
behaviour:

- Invocation: running 'interpreter' with no positional 'program' argument
  launches the REPL. The '-verbose' and '--traceback-json' flags keep the
  same meanings in the REPL as in batch mode.
- Prompting and input: the REPL presents a primary prompt for new top-level
  input and a continuation prompt while the user is entering a multi-line
  block (for example, the body of 'FUNC', 'IF', 'WHILE', or 'FOR').
- Single-line execution: when the user enters a single complete top-level
  statement (for example 'x = 1010' or 'PRINT(x)'), the REPL parses and
  executes that statement immediately and prints any side-effect output.
  This means 'EXIT()' typed as a single-line statement will terminate the
  REPL immediately and return the supplied exit code (or '0' if omitted),
  identical to the behaviour when 'EXIT()' is executed in a file.
- Multi-line buffering: if a statement begins a block (for example a 'FUNC'
  definition or an 'IF(...)[' that spans multiple lines), the REPL buffers
  lines until the block is complete (a blank line may be used to indicate
  end-of-entry when appropriate). When the buffer is complete the REPL
  parses and executes the collected statements as a unit.
- Environment persistence: variables, function definitions, and the state
  logger persist for the duration of the REPL session (that is, top-level
  bindings remain available across successive inputs until explicitly
  deleted with 'DEL(name)'). This lets the user incrementally build up a
  program interactively.
- Deterministic logging and tracebacks: all REPL-executed statements are
  recorded in the same state log format used for file-mode execution. Errors
  produce tracebacks in the same concise and verbose modes; the '-verbose'
  flag causes the REPL to attach 'env_snapshot' entries in tracebacks when
  available.

Notes and examples:
- Start REPL: 'interpreter'
- Exit via meta-command: type '.exit' or press Ctrl-D (EOF)
- Exit programmatically: 'EXIT()' — this immediately terminates the
  interpreter and returns the specified exit code to the shell, just like in
  batch execution.


APIREF — Quick Reference
------------------------

This quick reference lists common built-in functions, operators and
statement signatures for fast lookup. Use this when you need the name or
argument shape but don't want to re-read the full specification.

Function / Operator Signatures (expression position)
- 'INPUT()' or 'INPUT' : returns a STR from the input stream; use 'INT' to
  coerce to an integer when needed
- 'PRINT(a1, a2, ..., aN)' : prints INT/STR arguments (side-effect), return
  value discarded
- 'ASSERT(a)' : crashes if 'INT-style' truthiness of 'a' is 0
- 'MAIN()' : 1 if executing in the primary program file, else 0 when in
  imported code
- 'DEL(x)' : delete variable 'x' from environment
- 'EXIT()' or 'EXIT(code)' : terminate program immediately with optional exit
  code (default 0)
- 'IMPORT(name)' : load and execute '<name>.asmln' beside the caller, sharing
  the caller's namespace
- 'INT(x)' : STR -> INT using empty/01/other rules; INT passthrough
- 'STR(x)' : INT -> binary-spelled STR; STR passthrough
- Binary literal: optional leading '-' (spaces/tabs/CR allowed after the dash)
  then '{0,1}+'
- String literal: '"' characters '"' (no escapes, no newlines)
- 'EXIST(x)' : returns '1' if the identifier 'x' exists in the current
  environment (searching enclosing environments), else '0'. The argument must
  be an identifier; supplying an expression that is not a plain identifier is a
  runtime error.

Arithmetic (INT only)
- 'ADD(a, b)' : a + b
- 'SUB(a, b)' : a - b
- 'MUL(a, b)' : a * b
- 'DIV(a, b)' : floor(a / b)
- 'CDIV(a, b)' : ceil(a / b)
- 'POW(a, b)' : a ^ b (b >= 0)
- 'MOD(a, b)' : remainder of a / b
- 'NEG(a)' : -a (additive inverse)
- 'ABS(a)' : absolute value of a
- 'GCD(a, b)' : greatest common divisor of a and b
- 'LCM(a, b)' : least common multiple of a and b

Bitwise / Boolean
- Bitwise INT-only: 'BAND', 'BOR', 'BXOR', 'BNOT', 'SHL', 'SHR'
- 'SLICE(a, hi, lo)' : INT target -> bit-slice [hi:lo]; STR target ->
  inclusive char-slice counting from the right (index 0 = last char); 'hi'
  and 'lo' must be INT
- Boolean operators ('AND', 'OR', 'XOR', 'NOT') treat empty strings as 0 and
  non-empty strings as 1; always return INT 0/1

Comparisons
- 'EQ(a, b)' : 1 if a == b else 0
- 'GT(a, b)' : 1 if a > b else 0
- 'LT(a, b)' : 1 if a < b else 0
- 'GTE(a, b)' : 1 if a >= b else 0
- 'LTE(a, b)' : 1 if a <= b else 0

Aggregates / Utilities
- 'MAX(a1, ..., aN)' : INT -> numeric max; STR -> longest string; mixing INT
  and STR is an error
- 'MIN(a1, ..., aN)' : INT -> numeric min; STR -> shortest string; mixing INT
  and STR is an error
- 'SUM(a1, ..., aN)' : sum of INT arguments (INT only)
- 'LEN(a1, ..., aN)' : number of arguments (N), accepts INT or STR
- 'ALL(a1, ..., aN)' : Boolean AND (empty string -> false, non-empty -> true)
- 'ANY(a1, ..., aN)' : Boolean OR (empty string -> false, non-empty -> true)
- 'JOIN(a1, ..., aN)' : INT -> concatenate binary spellings with consistent
  sign; STR -> concatenate strings; mixing INT and STR is an error
- 'PROD(a1, ..., aN)' : product of INT arguments (INT only)

Logarithms
- 'LOG(a)' : floor(log2(a)) for a > 0
- 'CLOG(a)' : ceil(log2(a)) for a > 0

Control / Function / Statement Signatures (statement position)
- Assignment: 'TYPE : identifier = expression' on first use; subsequent
  assignments omit TYPE but must match the original type
- Block: '[ statement1 ... statementN ]' or '{ statement1 ... statementN }'
- 'IF(condition)[ block ]'
  (optional 'ELSIF(condition)[ block ]' ... 'ELSE[ block ]')
- 'WHILE(condition)[ block ]'
- 'FOR(counter, target)[ block ]' : 'counter' initialized to 0, loop until
  counter >= target
- 'FUNC name(T1:arg1, T2:arg2, ..., TN:argN):R[ block ]' : typed function
  definition with return type R
- 'RETURN(a)' : return from function with value 'a'
- 'BREAK(n)' : break out of the innermost 'n' enclosing loops; raises a
  runtime error if 'n' ≤ 0 or if 'n' is greater than the current loop nesting
  depth
- 'CONTINUE()' : skip remaining statements in the innermost loop iteration
  and proceed to the next iteration; if used in the last iteration it acts
  like 'BREAK(1)'. Using 'CONTINUE()' outside of a loop is a runtime error.
- 'GOTOPOINT(n)' : register a gotopoint with identifier 'n' at this statement's
  location (identifier may be INT or STR)
  (n evaluated at runtime). Gotopoints are visible across the containing
  function or top-level scope rather than being restricted to a single
  lexical block.
- 'GOTO(n)' : jump to a previously-registered gotopoint with identifier 'n'
  (INT or STR) within the same function or top-level scope; runtime error if not
  registered in that scope

Notes
- Built-ins are statically typed. Boolean contexts treat INT 0 as false and
  non-zero as true; STR is false when empty and true when non-empty unless a
  rule explicitly converts via 'INT'.
- Argument evaluation order: left-to-right.
- User-defined functions use the same call syntax as built-ins.