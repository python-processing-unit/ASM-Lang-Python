Abstract State Machine Language Specification
==============================================

This document specifies an imperative programming language with a binary
integer data model and an explicit small-step execution semantics. A program
is compiled into an initial machine state (a seed configuration) and then
executed solely by repeatedly applying a fixed, program-independent
state-transition (rewrite) function. All intermediate states are
(semi-)human-readable and serializable, and execution can be traced and
replayed exactly, including I/O and nondeterministic choices, which are modeled
explicitly for deterministic replay.

1. Overview
-----------

The language is a familiar statement-based, imperative language. Programs
consist of variable declarations via assignment, expressions, and
control-flow constructs such as 'IF', 'ELSIF', 'ELSE', 'WHILE', and 'FOR'.
All data values are (conceptually unbounded) binary integers, interpreted as
either signed or unsigned according to the implementation. Computation
proceeds by evaluating expressions and executing statements in sequence, with
explicit constructs for branching and looping. Input and output are modeled
through built-in operators, in particular 'INPUT' and 'PRINT'.

The interpreter compiles source code into a single initial configuration (the
seed state), which includes the program code, an empty variable environment,
and an initial I/O history. It then advances execution by repeatedly applying
a single, fixed small-step transition function that is independent of the
particular program. A disassembler and log view expose all intermediate
states so that every step and every control-flow decision is inspectable and
replay-able.


2. Lexical Structure
--------------------

Source files are sequences of ASCII characters. Non-ASCII characters are not
permitted in syntactic elements that enter the program namespace, such as
identifiers.

Whitespace consists of the space character ('U+0020'), horizontal tab,
carriage return, and line feed. It may appear freely between tokens and is
otherwise ignored, except that newlines delimit top-level statements (see
Section 5.1).

A comment begins with the '#' character and continues to the end of the
current line. Comments have no effect on execution.

The program text is divided into several token kinds: binary integer
literals (Section 3.1); identifiers for variable names and user-defined
function names (Section 2.5); keywords and built-ins (control-flow
keywords, built-in operators and functions; see Sections 4 and 5); and
delimiters, namely '(', ')', '[', ']', '{', '}', ',', and '='.

Keywords: The language's reserved keywords (for example, 'IF', 'WHILE',
'FUNC', etc.) are matched by the lexer exactly as listed in this
specification and are case-sensitive. Programs must use the keywords in
their canonical uppercase form; otherwise the token will be recognized as
an identifier. Built-in operator names such as 'INPUT', 'PRINT', and
'IMPORT' follow the same case-sensitive matching rules.

Line continuation: The character '^' serves as a line-continuation marker.
When a caret '^' appears in the source and is followed immediately by a
newline, both the '^' and the newline are ignored by the lexer (that is,
the logical line continues on the next physical line). If a caret appears
and is not immediately followed by a newline (or the platform's
single-character newline sequence), the lexer must raise a syntax error.

The character '-' is not an operator token. It is permitted only as the
leading sign of a binary integer literal (Section 3.1). If '-' appears
anywhere else, the lexer must raise a syntax error. When '-' starts a
literal, any spaces, horizontal tabs, or carriage returns between the '-'
and the first digit are ignored and the literal is treated as negative.

Identifiers denote variables and user-defined functions. They must be
non-empty and case-sensitive. An identifier must not contain non-ASCII
characters, nor any of the following characters: '{', '}', '[', ']', '(',
')', '=', ',', '#'. The first character of an identifier must not be the
digit '0' or '1' (these digits are used to begin binary integer literals).
However, the characters '0' and '1' are permitted in subsequent positions
within an identifier (for example, `a01` and `X10Y` are valid identifiers,
while `0foo` and `1bar` are not). The namespace is flat: variables and
functions share a single identifier space, so a given name cannot
simultaneously denote both. A user-defined function name must not conflict
with the name of any built-in operator or function (see Section 4.1).

Identifier character set (clarification): The first character of an
identifier MUST be an ASCII letter (A–Z or a–z) or underscore ('_').
Subsequent characters MAY be ASCII letters, underscore, or the binary
digits '0' and '1' only. Decimal digits other than '0' and '1' (that is,
'2'..'9') and the dot character '.' are NOT permitted inside identifiers.
Identifiers therefore cannot contain '.' (dot) and may not include any
non-binary digits; this preserves an unambiguous lexical distinction
between binary integer literals and identifiers, and prevents confusion
with module-qualified names (which are formed by a separate dotted name
syntax documented elsewhere in this specification).


3. Data Model
-------------

The sole literal data type is the binary integer. A binary integer literal is
either (1) an unsigned non-empty sequence of characters drawn from the set
'{0,1}' (for example, '0', '1', '1011', '100110'), or (2) a signed literal
formed by a leading '-' followed by optional whitespace (spaces, horizontal
tabs, or carriage returns) and then a non-empty sequence of '{0,1}'. The '-'
is part of the literal spelling and is not an operator; it may only appear in
this leading position. A '-' that is not immediately introducing a literal is
a syntax error.

Every runtime value is a mathematical integer. The language does not support
fractional or real-valued numbers. All operations that would otherwise
produce non-integer results, such as division, are defined with explicit
rounding behavior (see Section 4.2).


4. Expressions and Operators
----------------------------

All operators and functions, both built-in and user-defined, share a uniform
function-call style syntax of the form 'NAME(arg1, arg2, ..., argN)'. The
argument list may be empty for certain functions such as 'INPUT'. Arguments
are separated by commas, and spaces may appear around commas and inside
parentheses without changing meaning. Each operator has either a fixed or a
variable arity as described below.

All built-ins operate on integer values and, unless explicitly stated
otherwise, return an integer result. The language has no separate Boolean
type; instead, integers are interpreted as Boolean values in conditional or
logical contexts, with '0' representing false and any non-zero value
representing true. Boolean operators always return '0' or '1'. Unless
explicitly noted, any multi-argument operator requires at least one
argument.

Logical operators 'AND(a, b)', 'OR(a, b)', 'XOR(a, b)', and 'NOT(a)' operate
on the Boolean interpretation of their integer arguments. 'AND' returns '1'
only if both arguments are non-zero, 'OR' returns '1' if at least one is
non-zero, and 'XOR' returns '1' if exactly one is non-zero. 'NOT' returns '1'
if its argument is '0'; otherwise it returns '0'.

Bitwise operators act on the binary representation of integers. 'BAND(a, b)'
computes a bitwise AND, 'BOR(a, b)' a bitwise OR, 'BXOR(a, b)' a bitwise XOR,
and 'BNOT(a)' the bitwise complement. 'SHL(a, b)' shifts 'a' left by 'b' bits
and 'SHR(a, b)' shifts 'a' right by 'b' bits using arithmetic right-shift
(matching two's-complement semantics). Shift counts must be non-negative or
execution raises a runtime error. The interpretation of sign and bit width for
these operations is implementation-defined but must be consistent across all
bitwise operators.

Bitfield and slicing helpers: 'SLICE(a, hi, lo)' extracts the inclusive
bit-range [hi:lo] from the binary representation of 'a' and returns it as an
unsigned integer. Bits are numbered starting at 0 for the least-significant
bit. If 'hi < lo' or either index is negative, the operation raises a
runtime error. For negative values of 'a', implementations use the low-order
bits of its two's-complement representation (consistent with other bitwise
operations).

Arithmetic operators include 'ADD(a, b)' for integer addition, 'SUB(a, b)'
for subtraction ('a - b'), and 'MUL(a, b)' for multiplication. 'DIV(a, b)'
performs integer division with floor rounding, returning '⌊a / b⌋'; division
by zero is implementation-defined but should raise a runtime error.
'CDIV(a, b)' performs integer division with ceiling rounding, returning
'⌈a / b⌉' and similarly treating division by zero as an error.
'POW(a, b)' computes integer exponentiation 'a^b' for integer exponents
'b ≥ 0'; behavior for negative exponents is undefined or
implementation-defined. The modulus operator 'MOD(a, b)' returns the
remainder of dividing 'a' by 'b', typically chosen so that
'0 ≤ result < |b|', with the exact convention fixed by the implementation.

The unary operator 'NEG(a)' returns the additive inverse of 'a' (that is,
the value '-a'). The unary operator 'ABS(a)' returns the absolute value of
'a' (that is, 'a' if 'a ≥ 0' and '-a' otherwise).

The arithmetic library also provides functions for common number-theoretic
operations. 'GCD(a, b)' returns the greatest common divisor of 'a' and 'b'
for integer arguments, with the convention that 'GCD(0, 0)' is
implementation-defined (commonly 0). 'LCM(a, b)' returns the least common
multiple of 'a' and 'b' for integer arguments; if either argument is 0 the
result is typically 0, with exact behavior left to the implementation.

Finally, 'PROD(a1, a2, ..., aN)' computes the integer product of its
arguments (for 'N ≥ 1'); if any argument is '0' the result is '0'.

Several operators aggregate multiple arguments. 'MAX(a1, ..., aN)' and
'MIN(a1, ..., aN)' return, respectively, the larger and smaller of their two 
arguments. 'ALL(a1, ..., an)' performs a Boolean AND over any number of
arguments 'n ≥ 1', returning '1' if all are non-zero and '0' otherwise;
'ANY(a1,..., an)' performs a Boolean OR over any number of arguments, returning
'1' if at least one is non-zero and '0' otherwise. 'SUM(a1, a2, ..., an)'
computes the integer sum of its arguments. 'LEN(a1, a2, ..., an)' returns the
number of arguments supplied, that is, 'n'. 'JOIN(a1, ..., aN)' concatenates
the binary spellings of its arguments in call order and returns the integer
whose binary representation is that concatenation. All arguments must share
the same sign: either every argument is non-negative (the usual case), or
every argument is negative. When all arguments are non-negative the result
is the non-negative integer whose binary representation is the concatenation
of the arguments' binary spellings (for example, 'JOIN(10,1)' -> '101'). When
all arguments are negative the function concatenates the binary spellings of
the absolute values and returns the negation of the resulting integer
(for example, 'JOIN(-10,-1)' -> '-101'). Supplying a mixture of positive and
negative arguments is a runtime error.

Logarithmic operators are defined in base 2. 'LOG(a)' returns the floor of
the base-2 logarithm: for 'a > 0', it is the greatest integer 'k' such that
'2^k ≤ a'. 'CLOG(a)' returns the ceiling of the base-2 logarithm: for
'a > 0', it is the smallest integer 'k' such that '2^k ≥ a'. For 'a ≤ 0',
both 'LOG' and 'CLOG' have implementation-defined behavior and should raise
a runtime error.

Comparison operators return '1' if the comparison holds and '0' otherwise.
'EQ(a, b)' tests equality, while 'GT(a, b)' and 'LT(a, b)' test strict
greater-than and strict less-than, respectively. 'GTE(a, b)' tests
greater-than-or-equal and 'LTE(a, b)' tests less-than-or-equal.

Input, output, and assertions are expressed through dedicated operators.
'PRINT(a1, a2, ..., an)' outputs its arguments to the console in an
implementation-defined textual format. It is typically used in statement
position, and any return value is discarded. The effect on the external
world is recorded in the execution log, ensuring that replay remains
deterministic.

'IMPORT(name)' loads and executes another source file as a distinct module
namespace. The argument must be an identifier naming a module; the
interpreter first looks for a file named '<name>.asmln' in the same
directory as the current source file. When the current source is provided
via the '-source' string literal mode, the primary search directory is the
process's current working directory. If the module file is not found in
that location, the interpreter will additionally attempt to load the file
from a `lib` subdirectory located alongside the interpreter implementation
(that is, '<interpreter_dir>/lib/<name>.asmln', where '<interpreter_dir>' is
the directory containing the interpreter script or executable).

The imported file is parsed and executed in its own isolated top-level
environment: top-level assignments and function definitions in the imported
module do not directly mutate the caller's environment. During execution
inside the imported module, unqualified identifiers (for example, `x` or
`helper`) refer to names in the module's own top-level namespace. Qualified
identifiers (for example, `other.FOO`) refer only to the dotted names that
the module itself has created or imported; in other words, a module may
refer to its own imports via qualified names, and those qualified bindings
are scoped to that module's namespace.

After the module finishes executing, each top-level binding exported by the
module is made available to the importer under a dotted name formed by the
module identifier and the exported symbol, for example `module.FOO` or
`module.bar`. If the imported module itself imported other modules, those
nested qualified bindings are preserved under the importing module's
namespace (for example, `module.other.SYM` denotes a symbol that `module`
imported from `other`). Callers must reference imported symbols using the
qualified form (for example: `IMPORT(module)` followed by `module.FOO()`),
which preserves a clear separation of namespaces between modules.

Each 'IMPORT' call executes the target module anew and then publishes its
top-level bindings under the dotted module namespace in the caller's
environment; there is no automatic caching or cycle detection. Importantly,
IMPORT does not modify or remove the original bindings of modules that the
imported module relied upon; instead, nested qualified names are exposed
under the importer as dotted names rooted at the imported module's
identifier.

'INPUT()' (or simply 'INPUT' in expression position) reads a value from the
console or input stream. If the incoming text is empty, the result is '0'.
If the text consists solely of the characters '0' and '1', it is interpreted
as the corresponding binary integer. Any other non-empty text yields the
result '1'. All I/O events, including inputs, are recorded in the execution
log for deterministic replay.

'ASSERT(a)' checks that its argument is true in the Boolean sense. If 'a' is
non-zero, execution proceeds normally; if 'a' is '0', the program crashes
with an assertion failure.

'MAIN()' returns '1' when the call site belongs to the primary program file
(the file passed as the interpreter's first argument, or '<string>' when
'-source' is used). It returns '0' when executed from code that came from an
'IMPORT' (including nested imports). The result is determined solely by the
source file that contains the call expression, not by the caller's call stack.

Program termination is exposed via 'EXIT'. 'EXIT()' or 'EXIT(code)' requests
immediate termination of the interpreter. If an integer 'code' is supplied,
it is used as the interpreter's process exit code; otherwise '0' is used.
Execution stops immediately when 'EXIT' is executed (no further statements
run), and an entry is recorded in the state log to make deterministic replay
possible. Using 'EXIT' inside a function terminates the entire program (not
just the function).

Memory-management and function-return behavior are also exposed via
operators. 'DEL(x)' deletes the variable 'x' from the current environment,
freeing its memory; any subsequent reference to 'x' is an error unless 'x'
is re-assigned. 'RETURN(a)', when executed inside a function body,
immediately terminates that function and returns the value of 'a' to the
caller. Executing 'RETURN' outside of a function is a runtime error.


5. Statements and Control Flow
------------------------------

A program consists of zero or more statements separated by newlines. Each
top-level expression or assignment must appear on its own line. The basic
statement forms are assignments of the form 'identifier = expression',
expression statements such as calls to 'PRINT' whose result is ignored,
control-flow constructs ('IF', 'ELSIF', 'ELSE', 'WHILE', and 'FOR'), and
function definitions ('FUNC' declarations; see Section 6).

Blocks group one or more statements and are enclosed in either square or
curly brackets: '[ statement1 ... statementN ]' or
'{ statement1 ... statementN }'. The two bracket styles are equivalent but
must match (that is, '[' closes with ']' and '{' closes with '}'). Blocks
serve as the bodies of control-flow constructs and functions.

Assignments have the syntax 'identifier = expression', with spaces around the
equals sign being optional. If the identifier does not yet exist, the
assignment creates it and assigns memory; if it already exists, its stored
value is overwritten. Variables are deallocated only when 'DEL(identifier)'
is executed.

The language provides 'IF', 'ELSIF', and 'ELSE' constructs for conditional
execution. An 'IF' statement has the general form 'IF(condition)[ block ]' or
'IF(condition){ block }'. Optional chained branches may follow: one or more
'ELSIF(condition)[ block ]' or 'ELSIF(condition){ block }' clauses and an
optional terminal 'ELSE[ block ]' or 'ELSE{ block }' clause. An 'ELSIF' or
'ELSE' must immediately follow an 'IF' or another 'ELSIF'; otherwise it is a
syntax error. At most one 'ELSE' may appear in a given chain. Evaluation
proceeds by first evaluating the condition of the initial 'IF'. If it is
non-zero, the associated block executes and the rest of the chain is
skipped. Otherwise, the conditions of subsequent 'ELSIF' clauses are
evaluated in order until one is non-zero; its block then executes and the
chain terminates. If no 'IF' or 'ELSIF' condition is satisfied and an
'ELSE' is present, the 'ELSE' block executes; if there is no 'ELSE', no block
in the chain executes.

Loops are provided via 'WHILE' and 'FOR'. A 'WHILE' loop has the form
'WHILE(condition)[ block ]' or 'WHILE(condition){ block }'. On each
iteration, the condition is evaluated; if it is non-zero, the block executes
and control returns to the start of the loop to evaluate the condition
again. If the condition evaluates to zero, the loop terminates and execution
continues with the next statement.

The 'FOR' construct has the form 'FOR(counter, target)[ block ]' or
'FOR(counter, target){ block }', where 'counter' is an identifier and
'target' is an expression. At loop entry, 'target' is evaluated once to a
value 'T', and 'counter' is initialized to '0', creating it if necessary.
The loop then repeats: if the current value of 'counter' is greater than or
equal to 'T', the loop exits; otherwise, the block executes and 'counter' is
incremented by '1' before the next iteration.

BREAK statement: The language provides a statement form 'BREAK(n)'
that terminates enclosing loops. When executed inside a loop body
(either a 'WHILE' or 'FOR' loop), 'BREAK(n)' breaks out of the
innermost 'n' loops and resumes execution at the statement following
those loops. The argument 'n' is evaluated as an integer at runtime and
must be strictly positive. If 'n ≤ 0' the interpreter raises a runtime
error. If 'n' is greater than the number of currently-enclosing loops
(that is, the statement would escape all surrounding loops), the
interpreter raises a runtime error rather than silently terminating the
program. Using 'BREAK' outside of any loop context similarly results in
an error. The exact error type and reporting information are
implementation-defined but should be recorded in the state log to make
replay and debugging deterministic.


6. Functions
------------

Functions are defined using the 'FUNC' keyword. The canonical form is
'FUNC name(arg1, arg2, ..., argN)[ block ]' or
'FUNC name(arg1, arg2, ..., argN){ block }', where 'name' is an identifier
and each 'argK' is an identifier. Defining a function binds 'name' to a
callable body with the specified formal parameters. As noted earlier,
function names must not conflict with the names of built-in operators or
functions.

A user-defined function is called with the same syntax as a built-in:
'name(expr1, expr2, ..., exprN)'. The arguments are evaluated
left-to-right, producing values that are then bound to the function’s formal
parameters in a new environment (activation record). The function body block
executes in this environment, which may or may not have access to
surrounding or global variables depending on the chosen scoping model
(static or dynamic, to be fixed by the implementation). If a 'RETURN(v)'
statement is executed within the body, the function terminates immediately
and yields 'v' as its result. If control reaches the end of the body without
encountering 'RETURN', the function’s return value is
implementation-defined, commonly taken to be '0'.

Built-in operators and functions can be viewed as pre-defined functions
provided by the runtime environment. User-defined functions share the same
call syntax and are distinguished only by their names and bodies. Because of
the shared namespace, a user-defined function is not permitted to use any name
already reserved for a built-in. Attempting to violate this will raise an
exception.


7. Variables and Memory Model
-----------------------------

A variable is created automatically upon first assignment, for example in
'foo = 1101'. It exists until 'DEL(foo)' is executed, at which point its
storage is freed and its name is removed from the environment. Referencing a
variable that has never been assigned, or that has been deleted, is a
runtime error.

The language assumes at least a global environment mapping identifiers to
integer values. Function calls create new environments for parameters and
local variables, as described in Section 6.2; the precise details of name
resolution depend on the chosen scoping rules.


8. Execution Model and Semantics
--------------------------------

The interpreter compiles the source program into an initial machine state,
called the seed configuration. This configuration contains at least the
parsed (and possibly transformed) program representation, the initial
variable environments such as an empty global environment, and an explicit
model of I/O and nondeterministic inputs, initially empty.

Execution is driven by a single, fixed, program-independent small-step
state-transition function 'step'. At each step, 'step' takes the current
state and produces the next one, encompassing expression evaluation,
statement execution, function call and return, and I/O events.

Every state produced during execution is serializable and human-readable.
The interpreter maintains a disassembler and log that record the sequence of
states visited, the program locations and conditions involved in each
control-flow decision, and all I/O actions with their corresponding values.
Because I/O and nondeterminism are modeled explicitly within the state, the
execution of any program can be deterministically replayed from its seed
configuration together with the recorded inputs.


9. Standard Library
----------

The standard library is a group of modules for common use cases distributed
with the interpreter.
It includes modules for:
- Collections: indexed lists of integers with efficient encoding and decoding.
- CSPRNG: Cryptographically secure (ChaCha20) pseudorandom number generation
  with seed management.
- Encryption: AES-GCM and RSA-OAEP encryption and decryption utilities.
- Hashes: SHA-256 hashing.
- Prime: primality testing and prime number generation, along with
  factorization and other common prime utilities.
- PRNG: Fast (LCG) pseudorandom number generation with seed management.

10. Tracebacks and Error Reporting

When a runtime error or exception occurs the interpreter must produce a
deterministic, human-readable traceback derived from the state log. The
traceback exposes the call stack (frames) at the point of failure and
associates each frame with both (1) a compact source-location description
and (2) the relevant serialized state sections and state-transformation
records from the state log. The goal is to provide developers with the
same immediate debugging information that Python's traceback provides but
with the additional ability to inspect the exact machine states and the
rewrite steps that led to the error for deterministic replay.

10.1 Traceback semantics (high level)


GOTOPOINT and GOTO: Two additional control-flow primitives allow program
execution to jump to a dynamically-registered program location. The
statement form 'GOTOPOINT(n)' evaluates the expression 'n' and registers a
gotopoint with that integer identifier at the point where the statement
executes. Registration occurs at runtime when the 'GOTOPOINT' statement
executes; subsequent execution (including execution within loops or after
imports) may depend on whether the gotopoint has been registered.

The statement form 'GOTO(n)' evaluates 'n' at runtime and transfers
execution to the previously-registered gotopoint whose identifier equals
'n'. If no gotopoint with that identifier has been registered in a scope
visible to the jump target, the interpreter raises a runtime error. GOTO
may jump forward or backward relative to the target gotopoint; jumping to
an unregistered identifier is an error. Gotopoints are not restricted to a
single lexical block: they are visible across the containing function (or
top-level program scope) in which they are defined. Implementations may
choose to expose an even broader scope (for example, process-wide), but by
default gotopoints registered within a function or at top-level are
available to any GOTO executed within the same function or top-level code.
This change enables cross-block jumps while preserving a clear containment
model: a GOTO cannot target a gotopoint defined in an unrelated function or
module unless the implementation explicitly exposes that mapping.

GOTO and GOTOPOINT are intended to be low-level primitives and their use
can make programs harder to reason about. They are serialized in the state
log like other statements so that execution is fully replayable for
debugging and tracing.
- Trigger: a traceback is produced when a runtime error occurs that
  prevents normal forward execution (e.g., an assertion failure, divide
  by zero, undefined variable reference, executing 'RETURN' outside of a
  function, or any other interpreter-defined runtime error).
- Content: the traceback must list frames in chronological call order
  from the outermost (earliest) frame to the innermost (where the
  error occurred), and for each frame include: function name (or
  '<top-level>' for global code), precise source location, a short
  excerpt of the offending statement, and identifiers linking to the
  corresponding states in the state log.
- State linkage: every frame must reference at least one serialized
  state snapshot from the state log that corresponds to the machine
  configuration immediately before the failing rewrite step for that
  frame. The innermost frame must also reference the rewrite (transition)
  record that produced the error (that is, the failing step).
- Presentation modes: the interpreter must support a concise textual
  traceback (default) and a verbose mode. The concise mode shows the
  usual file/line/function stack with a one-line code excerpt per
  frame and the state-log index. The verbose mode prints, for each
  frame, the selected state sections (for example: local environment,
  selected global variables, and the expression evaluation stack) and
  the full state-transformation record (from_state -> to_state, the
  rewrite rule name and arguments). The verbose mode is intended for
  interactive debugging and post-mortem inspection.

10.2 Required fields and invariants in the state log

To make tracebacks precise and implementable, the state log (and the
machine state representation) must include the following information at
every step when relevant:

- 'step_index' (integer): monotonically increasing index of the rewrite
  step in the state log.
- 'state_id' (opaque string or integer): stable identifier for the
  serialized machine state (seed, intermediate, or terminal).
- 'source_location' (optional): when a rewrite step is associated with a
  program location, include a 'source_location' record with at least the
  following fields: 'file' (string), 'line' (integer), and 'statement'
  (string containing the top-level statement text or canonical snippet).
- 'frame_id' (when present): identifier for the active call-frame in
  that state; frames must be addressable and referable by the traceback
  generator.
- 'env_snapshot' (selectable): a serialized partial view of the state
  containing bindings for the local variables of the active frame and,
  where reasonable, a subset of global variables. The interpreter may
  elide large or sensitive values by policy, but must provide a clear
  indication when values are elided.
- 'rewrite_record': for each step that performs a state transition, the
  log must include a record describing the rewrite rule (name, inputs,
  and parameters), and the 'from_state_id' and 'to_state_id' pairs.

10.3 Traceback textual format (recommended)

The following format is recommended for the concise textual traceback:

Traceback (most recent call last):
  File "<file>", line <line>, in <function_or_<top-level>>
    <statement excerpt>
    State log index: <step_index>  State id: <state_id>

The final (innermost) frame is then followed by a short error message
that includes the failing rewrite (for example: 'DivisionByZero'), the
rewrite rule name and the 'step_index' at which it failed. In verbose
mode, each frame block is followed by a labelled 'State snapshot:' and a
'State transformation:' section that contain the serialized 'env_snapshot'
and the 'rewrite_record' (including 'from_state_id' and 'to_state_id') so
that the failure can be reproduced by replaying the states and the
associated inputs.

10.4 Machine-readable traceback (JSON)

The interpreter must also be able to emit a machine-readable traceback
structure suitable for diagnostics tools and editors. A suggested JSON
schema is:

{
  "error": {
    "type": "DivisionByZero",
    "message": "Divide by zero in DIV(foo, 0)",
    "failing_step_index": 123
  },
  "traceback": [
    {
      "frame_index": 0,
      "name": "<top-level>",
      "source_location": {"file": "prog.asmln", "line": 12, "statement": "foo = INPUT"},
      "state_id": "s_0003",
      "step_index": 42,
      "env_snapshot": {"foo": 5, "bar": 10}
    },
    {
      "frame_index": 1,
      "name": "compute",
      "source_location": {"file": "lib.asmln", "line": 88, "statement": "DIV(a, b)"},
      "state_id": "s_0123",
      "step_index": 123,
      "env_snapshot": {"a": 17, "b": 0},
      "rewrite_record": {"rule": "DIV", "from_state_id": "s_0122", "to_state_id": "s_0123", "args": [17, 0]}
    }
  ]
}

The schema above is a guideline; implementations may extend it with
additional fields (for example, a Bitwise XOR between 'from_state' and
'to_state', or full serialized states). The only requirement is that a
consumer of the state log can identify which state and which rewrite
step correspond to each frame.

10.5 Point of origin in source code

The trace must clearly identify the point of origin (the expression or
statement that directly caused the error) by including the 'source_location'
and the 'step_index' of the failing rewrite. Implementations should also
include the exact token or sub-expression when available (for example,
the 'DIV(a,0)' call that produced the division-by-zero), and the
surrounding source excerpt (at least one line above and below, if
available) to make diagnosis easier.

10.6 Integrating tracebacks with the disassembler and replay

- The disassembler view must support jumping from a printed traceback to
  the corresponding state-log entry ('step_index') and to the
  reconstructed source location so that a user can inspect the full
  'from_state' and 'to_state' pair and step through the rewrite that
  produced the error.
- Because the state log records I/O and nondeterminism explicitly, the
  disassembler/replayer must be able to replay the exact failing step
  when given the seed configuration and the recorded inputs.

10.7 Implementation notes for builders

- The instrumentation needed for tracebacks is primarily bookkeeping:
  ensure the state log records 'step_index', 'state_id', 'frame_id', and
  optional 'source_location' for each step when appropriate.
- When collecting 'env_snapshot' data, prefer including only the local
  environment of the active frame and a small set of globals to keep
  tracebacks readable; provide a '--verbose' or similar flag to emit
  full snapshots.
- Security note: because state snapshots may contain sensitive data,
  implementations should provide a configurable policy to redact or
  obfuscate values when generating tracebacks for untrusted logs.

10.8 Example (concise textual traceback)

Traceback (most recent call last):
  File "prog.asmln", line 21, in <top-level>
    result = compute(foo, bar)
    State log index: 121  State id: s_0121
  File "lib.asmln", line 88, in compute
    x = DIV(a, b)
    State log index: 123  State id: s_0123
DivisionByZero: attempted to DIV by zero at step_index=123 (rewrite: DIV)

This example shows the outer call at the program top-level and the
innermost failing call in 'compute'. A verbose report would additionally
print the 'env_snapshot' for 'compute' showing 'a: 17, b: 0' and the
full 'rewrite_record' describing the DIV operation that failed.

  11. Interpreter Use
  -------------------

  This section documents how the reference interpreter accepts program input
  and how to enable verbose tracebacks that include environment snapshots.

  - Invocation arguments: the interpreter reads its first program argument
    (that is, 'argv[1]') as the program source. If the '-source' flag is not
    present, 'argv[1]' is interpreted as a path to a source file and the
    interpreter loads and parses that file. If the '-source' flag is present,
    'argv[1]' is treated as the source text itself (a string containing the
    program) and is parsed directly without reading a file.

  - Verbose tracebacks: if the '-verbose' flag is supplied on the command
    line, tracebacks include the environment snapshots described in
    Section 10.8. In concise traceback mode the '-verbose' flag causes the
    interpreter to attach an 'env_snapshot' entry to each frame shown; in
    verbose traceback mode the same flag expands the printed 'State snapshot:'
    blocks to include the selected local environment and any small set of
    globals included by policy. The snapshot contents follow the requirements
    in Section 10.2 and are suitable for deterministic replay.

  Notes:
  - The interpreter may support additional flags and a different ordering of
    arguments; the rules above define the semantics for 'argv[1]', '-source',
    and '-verbose' specifically and are intended to be stable for tooling and
    replay purposes.

  Example invocations (illustrative):
  - File mode: 'interpreter program.asm'
  - Source-string mode: 'interpreter -source "foo = INPUT\nPRINT(foo)"
    -verbose'

  - REPL / Interactive mode: 'interpreter' (no program argument)

REPL (Interactive Mode)
-----------------------

When the interpreter is invoked without a program path or a '-source' string
argument it enters an interactive read–eval–print loop (REPL). The REPL is a
convenient development and exploration environment that executes ASM-Lang
statements using the same parser, runtime, built-ins, and state-logging
semantics as file-mode execution. The following rules describe REPL
behaviour:

- Invocation: running 'interpreter' with no positional 'program' argument
  launches the REPL. The '-verbose' and '--traceback-json' flags keep the
  same meanings in the REPL as in batch mode.
- Prompting and input: the REPL presents a primary prompt for new top-level
  input and a continuation prompt while the user is entering a multi-line
  block (for example, the body of 'FUNC', 'IF', 'WHILE', or 'FOR').
- Single-line execution: when the user enters a single complete top-level
  statement (for example 'x = 1010' or 'PRINT(x)'), the REPL parses and
  executes that statement immediately and prints any side-effect output.
  This means 'EXIT()' typed as a single-line statement will terminate the
  REPL immediately and return the supplied exit code (or '0' if omitted),
  identical to the behaviour when 'EXIT()' is executed in a file.
- Multi-line buffering: if a statement begins a block (for example a 'FUNC'
  definition or an 'IF(...)[' that spans multiple lines), the REPL buffers
  lines until the block is complete (a blank line may be used to indicate
  end-of-entry when appropriate). When the buffer is complete the REPL
  parses and executes the collected statements as a unit.
- Environment persistence: variables, function definitions, and the state
  logger persist for the duration of the REPL session (that is, top-level
  bindings remain available across successive inputs until explicitly
  deleted with 'DEL(name)'). This lets the user incrementally build up a
  program interactively.
- Deterministic logging and tracebacks: all REPL-executed statements are
  recorded in the same state log format used for file-mode execution. Errors
  produce tracebacks in the same concise and verbose modes; the '-verbose'
  flag causes the REPL to attach 'env_snapshot' entries in tracebacks when
  available.

Notes and examples:
- Start REPL: 'interpreter'
- Exit via meta-command: type '.exit' or press Ctrl-D (EOF)
- Exit programmatically: 'EXIT()' — this immediately terminates the
  interpreter and returns the specified exit code to the shell, just like in
  batch execution.


APIREF — Quick Reference
------------------------

This quick reference lists common built-in functions, operators and
statement signatures for fast lookup. Use this when you need the name or
argument shape but don't want to re-read the full specification.

Function / Operator Signatures (expression position)
- 'INPUT()' or 'INPUT' : returns integer from input stream (0 for empty)
- 'PRINT(a1, a2, ..., aN)' : prints arguments (side-effect), return value
  discarded
- 'ASSERT(a)' : crashes if 'a' is 0
- 'MAIN()' : 1 if executing in the primary program file, else 0 when in
  imported code
- 'DEL(x)' : delete variable 'x' from environment
- 'EXIT()' or 'EXIT(code)' : terminate program immediately with optional exit
  code (default 0)
- 'IMPORT(name)' : load and execute '<name>.asmln' beside the caller, sharing
  the caller's namespace
- Binary literal: optional leading '-' (spaces/tabs/CR allowed after the dash)
  then '{0,1}+'
- 'EXIST(x)' : returns '1' if the identifier 'x' exists in the current
  environment (searching enclosing environments), else '0'. The argument must
  be an identifier; supplying an expression that is not a plain identifier is a
  runtime error.

Arithmetic
- 'ADD(a, b)' : a + b
- 'SUB(a, b)' : a - b
- 'MUL(a, b)' : a * b
- 'DIV(a, b)' : floor(a / b)
- 'CDIV(a, b)' : ceil(a / b)
- 'POW(a, b)' : a ^ b (b >= 0)
- 'MOD(a, b)' : remainder of a / b
- 'NEG(a)' : -a (additive inverse)
- 'ABS(a)' : absolute value of a
- 'GCD(a, b)' : greatest common divisor of a and b
- 'LCM(a, b)' : least common multiple of a and b

Bitwise / Boolean
- 'BAND(a, b)' : bitwise AND
- 'BOR(a, b)' : bitwise OR
- 'BXOR(a, b)' : bitwise XOR
- 'BNOT(a)' : bitwise complement
- 'SHL(a, b)' : arithmetic shift-left of 'a' by 'b' bits (b >= 0)
- 'SHR(a, b)' : arithmetic shift-right of 'a' by 'b' bits (b >= 0)
- 'SLICE(a, hi, lo)' : inclusive bit-slice of 'a' from bit index 'hi' down to
  'lo' (LSB index 0)
- 'AND(a, b)' : Boolean AND -> 0 or 1
- 'OR(a, b)' : Boolean OR -> 0 or 1
- 'XOR(a, b)' : Boolean XOR -> 0 or 1
- 'NOT(a)' : Boolean NOT -> 0 or 1

Comparisons
- 'EQ(a, b)' : 1 if a == b else 0
- 'GT(a, b)' : 1 if a > b else 0
- 'LT(a, b)' : 1 if a < b else 0
- 'GTE(a, b)' : 1 if a >= b else 0
- 'LTE(a, b)' : 1 if a <= b else 0

Aggregates / Utilities
- 'MAX(a1, ..., aN)' : max of arguments
- 'MIN(a1, ..., aN)' : min of arguments
- 'SUM(a1, ..., aN)' : sum of arguments
- 'LEN(a1, ..., aN)' : number of arguments (N)
- 'ALL(a1, ..., aN)' : 1 if all non-zero else 0
- 'ANY(a1, ..., aN)' : 1 if any non-zero else 0
- 'JOIN(a1, ..., aN)' : concatenate binary spellings of arguments; all must
  share sign (all non-negative or all negative). If all negative, result is
  the negation of the concatenation of absolute values.
- 'PROD(a1, ..., aN)' : product of arguments

Logarithms
- 'LOG(a)' : floor(log2(a)) for a > 0
- 'CLOG(a)' : ceil(log2(a)) for a > 0

Control / Function / Statement Signatures (statement position)
- Assignment: 'identifier = expression'
- Block: '[ statement1 ... statementN ]' or '{ statement1 ... statementN }'
- 'IF(condition)[ block ]'
  (optional 'ELSIF(condition)[ block ]' ... 'ELSE[ block ]')
- 'WHILE(condition)[ block ]'
- 'FOR(counter, target)[ block ]' : 'counter' initialized to 0, loop until
  counter >= target
- 'FUNC name(arg1, arg2, ..., argN)[ block ]' : defines a function
- 'RETURN(a)' : return from function with value 'a'
- 'BREAK(n)' : break out of the innermost 'n' enclosing loops; raises a
  runtime error if 'n' ≤ 0 or if 'n' is greater than the current loop nesting
  depth
- 'GOTOPOINT(n)' : register a gotopoint with identifier 'n' at this statement's
  location
  (n evaluated at runtime). Gotopoints are visible across the containing
  function or top-level scope rather than being restricted to a single
  lexical block.
- 'GOTO(n)' : jump to a previously-registered gotopoint with identifier 'n'
  within the same function or top-level scope; runtime error if not
  registered in that scope

Notes
- All built-ins return integers. Boolean contexts treat 0 as false and
  non-zero as true. Boolean operators return '0' or '1'.
- Argument evaluation order: left-to-right.
- User-defined functions use the same call syntax as built-ins.