IMPORT(prng)
IMPORT(csprng)
IMPORT(prime)
IMPORT(decimal)
IMPORT(path)
IMPORT(image)
IMPORT(waveforms)
IMPORT(stats)

FUNC STDLIB_TESTS():INT{
    PRINT("Running library tests...")

    # PRNG reproducibility (LCG)
    prng.PRNG_SEED(1010)   # seed = 10
    INT: a = prng.PRNG_NEXT()
    prng.PRNG_SEED(1010)
    INT: b = prng.PRNG_NEXT()
    ASSERT( EQ(a, b) )
    DEL(a)
    DEL(b)

    PRINT("PRNG tests passed.")

    # CSPRNG reproducibility (ChaCha-based)
    csprng.CS_PRNG_SEED(101)  # seed = 5
    INT: x = csprng.CS_PRNG_NEXT()
    csprng.CS_PRNG_SEED(101)
    INT: y = csprng.CS_PRNG_NEXT()
    ASSERT( EQ(x, y) )
    DEL(x)
    DEL(y)
    PRINT("CSPRNG tests passed.")

    # Prime library tests
    # Basic primality checks
    ASSERT( EQ( prime.IS_PRIME(10), 1 ) )    # 2 is prime
    ASSERT( EQ( prime.IS_PRIME(11), 1 ) )    # 3 is prime
    ASSERT( EQ( prime.IS_PRIME(100), 0 ) )   # 4 is not prime
    ASSERT( EQ( prime.IS_PRIME(101), 1 ) )   # 5 is prime

    # NEXT_PRIME / PREV_PRIME
    ASSERT( EQ( prime.NEXT_PRIME(100), 101 ) )   # next prime after 4 is 5
    ASSERT( EQ( prime.PREV_PRIME(101), 11 ) )    # previous prime before 5 is 3

    # Mersenne prime check (p=3 -> 2^3-1 = 7, prime)
    ASSERT( EQ( prime.IS_MERSENNE_PRIME(11), 1 ) )

    # FACTOR: factor 10 (1010) -> [2 (10), 5 (101)]
    TNS: factors = prime.FACTOR(1010)
    ASSERT( EQ( TLEN(factors, 1), 10 ) )
    ASSERT( EQ( factors[1], 10 ) )
    ASSERT( EQ( factors[10], 101 ) )
    DEL(factors)

    PRINT("Prime library tests passed.")

    # Decimal library tests
    ASSERT(EQ(decimal.INT_TO_DEC(100),"4"))
    ASSERT(EQ(decimal.DEC_TO_INT("4"),100))
    ASSERT(EQ(decimal.INT_TO_DEC(-100),"-4"))
    ASSERT(EQ(decimal.DEC_TO_INT("-4"),-100))

    PRINT("Decimal library tests passed.")

    # Path library tests
    ASSERT( EQ(path.NORMALIZE_PATH("a\b\c"), "a/b/c") )
    ASSERT( EQ(path.WINPATH("a/b/c"), "a\b\c") )
    ASSERT( EQ(path.BASENAME("a/b/c.txt"), "c.txt") )
    ASSERT( EQ(path.EXTNAME("foo.bar"), "bar") )
    ASSERT( EQ(path.DELEXT("foo.bar"), "foo") )
    ASSERT( EQ(path.EXTNAME("foo"), "") )
    ASSERT( EQ(path.DELEXT("foo"), "foo") )
    IF(EQ(OS(),"win")){
        ASSERT( EQ(path.TEMPFILE("myfile.txt"), "C:/Windows/Temp/myfile.txt") )
    }

    PRINT("Path library tests passed.")

    # Waveform library tests
    INT: freq = 1100100      # 100
    INT: ms = 1010           # 10
    INT: amp = 1010          # 10
    INT: sr = 1111101000     # 1000
    INT: duty0 = 0
    INT: duty50 = 110010     # 50

    # Generators
    TNS: sq = waveforms.SQUARE(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(sq, 1), ms))
    ASSERT(EQ(sq[1], amp))
    ASSERT(EQ(sq[110], NEG(amp)))

    TNS: saw = waveforms.SAWTOOTH(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(saw, 1), ms))
    ASSERT(EQ(saw[1], NEG(amp)))
    ASSERT(EQ(saw[10], NEG(110)))   # -6
    ASSERT(EQ(saw[1010], 11010))    # 26
    DEL(saw)

    TNS: tri = waveforms.TRIANGLE(freq, ms, amp, sr)
    ASSERT(EQ(TLEN(tri, 1), ms))
    ASSERT(EQ(tri[1], NEG(amp)))
    ASSERT(EQ(tri[110], amp))
    ASSERT(EQ(tri[1010], NEG(110)))
    DEL(tri)

    TNS: pulse0 = waveforms.PULSE(freq, ms, amp, sr, duty0)
    DEL(duty0)
    ASSERT(EQ(TLEN(pulse0, 1), ms))
    ASSERT(EQ(pulse0[1], NEG(amp)))
    DEL(pulse0)

    TNS: pulse50 = waveforms.PULSE(freq, ms, amp, sr, duty50)
    DEL(duty50)
    ASSERT(EQ(TLEN(pulse50, 1), ms))
    ASSERT(EQ(pulse50[1], amp))
    ASSERT(EQ(pulse50[110], NEG(amp)))
    DEL(amp)
    DEL(pulse50)

    TNS: sine0 = waveforms.SINE(freq, ms, 0, sr)
    DEL(sr)
    ASSERT(EQ(TLEN(sine0, 1), ms))
    ASSERT(EQ(sine0[1], 0))
    ASSERT(EQ(sine0[1010], 0))
    DEL(freq)
    DEL(sine0)

    # Filters
    TNS: env = waveforms.ENVELOPE_ADSR(SHAPE(sq), 10, 10, 10, 10)
    DEL(sq)
    ASSERT(EQ(TLEN(env, 1), ms))
    DEL(ms)
    ASSERT(EQ(env[1], 10))
    ASSERT(EQ(env[101], 10))
    ASSERT(EQ(env[1010], 1))
    DEL(env)

    TNS: filt_in = [0, 1, 10]
    TNS: low = waveforms.LOWPASS(filt_in, 1100100, 1100100)
    ASSERT(EQ(TLEN(low, 1), 11))
    ASSERT(EQ(low[1], 0))
    ASSERT(EQ(low[10], 1))
    ASSERT(EQ(low[11], 10))
    DEL(low)

    TNS: high = waveforms.HIGHPASS(filt_in, 1100100, 1100100)
    DEL(filt_in)
    ASSERT(EQ(TLEN(high, 1), 11))
    ASSERT(EQ(high[1], 0))
    ASSERT(EQ(high[11], 0))
    DEL(high)

    PRINT("Waveform library tests passed.")

    # Stats library tests
    TNS: svals1 = [1,10,11]  # values: 1,2,3 (binary literals)
    ASSERT( EQ( stats.MEAN(svals1), 10.0 ) )     # mean = 2.0
    ASSERT( EQ( stats.MEDIAN(svals1), 10.0 ) )   # median = 2.0

    TNS: svals2 = [1,10,11,100]  # values: 1,2,3,4
    ASSERT( EQ( stats.MEAN(svals2), 10.1 ) )     # mean = 2.5 (10.1)
    ASSERT( EQ( stats.MEDIAN(svals2), 10.1 ) )   # median = 2.5 (10.1)
    DEL(svals2)

    # Quantile: q=0 should return minimum
    ASSERT( EQ( stats.QUANTILE(svals1, 0, 10), 1.0 ) )

    # Variance / stdev (population) for [1,2,3] is small -> integer division yields 0
    ASSERT( EQ( stats.VARIANCE(svals1, 0), 0.0 ) )
    ASSERT( EQ( stats.STDEV(svals1, 0), 0.0 ) )

    TNS: mode1 = stats.MODE(svals1)
    # All values appear once -> all are modes (length 3 -> binary '11')
    ASSERT( EQ( TLEN(mode1, 1), 11 ) )
    DEL(mode1)

    # Histogram with 2 bins (bins=10 binary) -> first bin count 2, second bin 1
    TNS: hist1 = stats.HISTOGRAM(svals1, 10)
    ASSERT( EQ( TLEN(hist1, 1), 10 ) )
    ASSERT( EQ( hist1[1], 10 ) )
    ASSERT( EQ( hist1[10], 1 ) )
    DEL(hist1)

    TNS: desc1 = stats.DESCRIBE(svals1)
    DEL(svals1)
    ASSERT( EQ( TLEN(desc1, 1), 101 ) )   # length 5 -> binary 101
    ASSERT( EQ( desc1[1], 11 ) )          # count = 3
    ASSERT( EQ( desc1[10], 10 ) )          # mean = 2
    ASSERT( EQ( desc1[11], 0 ) )           # stdev (as implemented)
    ASSERT( EQ( desc1[100], 1 ) )           # min
    ASSERT( EQ( desc1[101], 11 ) )          # max
    DEL(desc1)
    PRINT("Stats library tests passed.")

    # image library
    STR: bmp_path = JOIN(path.interpreter_dir,"/icon.bmp")
    STR: png_path = JOIN(path.interpreter_dir,"/icon.png")
    STR: jpeg_path = JOIN(path.interpreter_dir,"/icon.jpg")
    TNS: bmp = image.LOAD_BMP(bmp_path)
    DEL(bmp_path)
    TNS: png = image.LOAD_PNG(png_path)
    DEL(png_path)
    # Convenience loader (auto-detect)
    TNS: auto_png = image.LOAD_IMG(JOIN(path.interpreter_dir, "/icon.png"))
    ASSERT(EQ(auto_png, png))
    DEL(auto_png)
    image.LOAD_JPEG(jpeg_path)
    DEL(jpeg_path)
    ASSERT(EQ(bmp, png))
    ASSERT(EQ(image.FLIP_V(image.FLIP_V(bmp)), bmp))
    ASSERT(EQ(image.FLIP_H(image.FLIP_H(bmp)), bmp))
    ASSERT(EQ(image.WIDTH(bmp), 10101010))
    ASSERT(EQ(image.HEIGHT(bmp), 10101010))
    ASSERT(EQ(image.CHANNELS(bmp), 100))

    # Pixel / channel access consistency
    TNS: p = image.PIXEL(bmp, 1, 1)
    ASSERT(EQ(p[1], image.PIXEL_R(bmp, 1, 1)))
    ASSERT(EQ(p[10], image.PIXEL_G(bmp, 1, 1)))
    ASSERT(EQ(p[11], image.PIXEL_B(bmp, 1, 1)))
    ASSERT(EQ(p[100], image.PIXEL_A(bmp, 1, 1)))
    DEL(p)

    # Channel extractor helpers (R/G/B/A)
    ASSERT(EQ(image.R(bmp)[1,1], image.PIXEL_R(bmp, 1, 1)))
    ASSERT(EQ(image.G(bmp)[1,1], image.PIXEL_G(bmp, 1, 1)))
    ASSERT(EQ(image.B(bmp)[1,1], image.PIXEL_B(bmp, 1, 1)))
    ASSERT(EQ(image.A(bmp)[1,1], image.PIXEL_A(bmp, 1, 1)))

    # Double-invert returns original
    ASSERT(EQ(image.INVERT(image.INVERT(bmp)), bmp))

    # REPLACE_COLOR: draw a filled rect and replace red with green
    TNS: canvas_rc = TNS([1011,1011,100], 0)
    TNS: redcol = [11111111, 0, 0, 11111111]
    TNS: greencol = [0, 11111111, 0, 11111111]
    TNS: filled_rc = image.FILL_RECT(canvas_rc, 1, 1, 1011, 1011, redcol)
    DEL(canvas_rc)
    TNS: replaced = image.REPLACE_COLOR(filled_rc, redcol, greencol)
    DEL(redcol)
    DEL(greencol)
    DEL(filled_rc)
    ASSERT(EQ(image.PIXEL_R(replaced, 1, 1), 0))
    ASSERT(EQ(image.PIXEL_G(replaced, 1, 1), 11111111))
    DEL(replaced)

    # Scale (identity) preserves dimensions
    TNS: scaled = image.SCALE(bmp, 1, 1, 1)
    ASSERT(EQ(image.WIDTH(scaled), image.WIDTH(bmp)))
    ASSERT(EQ(image.HEIGHT(scaled), image.HEIGHT(bmp)))
    DEL(scaled)

    # Blit into an empty canvas and verify top-left pixel copied
    TNS: canvas = TNS(SHAPE(bmp), 0)
    TNS: canv2 = image.BLIT(bmp, canvas, 1, 1)
    DEL(canvas)
    ASSERT(EQ(canv2[1,1,1], bmp[1,1,1]))
    DEL(canv2)

    # Grayscale / Blur run and preserve height
    TNS: gray = image.GRAYSCALE(bmp)
    ASSERT(EQ(TLEN(gray, 1), TLEN(bmp, 1)))
    DEL(gray)
    TNS: blurred = image.BLUR(bmp, 1)
    ASSERT(EQ(TLEN(blurred, 1), TLEN(bmp, 1)))
    DEL(blurred)

    # Additional image operator coverage
    STR: out_bmp = JOIN(path.interpreter_dir, "/out_test.bmp")
    STR: out_png = JOIN(path.interpreter_dir, "/out_test.png")
    DEL(png)
    STR: out_jpeg = JOIN(path.interpreter_dir, "/out_test.jpg")

    # SHOW (only run on Windows to avoid opening viewers on other platforms)
    IF(EQ(OS(), "win")){
        INT: show_rc = image.SHOW(bmp)
        ASSERT(EQ(show_rc, 0))
        DEL(show_rc)
    }

    # SAVE/LOAD roundtrip (BMP/PNG/JPEG)
    ASSERT(EQ(image.SAVE_BMP(bmp, out_bmp), "OK"))
    TNS: bmp_rt = image.LOAD_BMP(out_bmp)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_bmp,'/','\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_bmp, '"'))
    }
    DEL(out_bmp)
    ASSERT(EQ(bmp_rt, bmp))
    DEL(bmp_rt)

    ASSERT(EQ(image.SAVE_PNG(bmp, out_png, 1010), "OK"))
    TNS: png_rt = image.LOAD_PNG(out_png)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_png,'/','\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_png, '"'))
    }
    DEL(out_png)
    ASSERT(EQ(png_rt, bmp))
    DEL(png_rt)
    # Use a high JPEG quality (95 -> binary 1011111). JPEG is lossy so
    # require dimensions match and per-channel values be close.
    ASSERT(EQ(image.SAVE_JPEG(bmp, out_jpeg, 1011111), "OK"))
    TNS: jpeg_rt2 = image.LOAD_JPEG(out_jpeg)
    IF(EQ(OS(),"win")){
        CL(JOIN('del "', REPLACE(out_jpeg,'/','\'), '"'))
    } ELSE {
        CL(JOIN('rm "', out_jpeg, '"'))
    }
    DEL(out_jpeg)
    ASSERT(EQ(image.WIDTH(jpeg_rt2), image.WIDTH(bmp)))
    ASSERT(EQ(image.HEIGHT(jpeg_rt2), image.HEIGHT(bmp)))
    ASSERT(EQ(image.CHANNELS(jpeg_rt2), image.CHANNELS(bmp)))
    INT: dr = ABS(SUB(image.PIXEL_R(jpeg_rt2, 1, 1), image.PIXEL_R(bmp, 1, 1)))
    INT: dg = ABS(SUB(image.PIXEL_G(jpeg_rt2, 1, 1), image.PIXEL_G(bmp, 1, 1)))
    INT: db = ABS(SUB(image.PIXEL_B(jpeg_rt2, 1, 1), image.PIXEL_B(bmp, 1, 1)))
    DEL(jpeg_rt2)
    # allow small per-channel differences (<=3)
    ASSERT(LTE(dr, 11))
    DEL(dr)
    ASSERT(LTE(dg, 11))
    DEL(dg)
    ASSERT(LTE(db, 11))
    DEL(db)

    # CROP with zeros returns identical image (new signature: corners tensor)
    TNS: crop_same = image.CROP(bmp, [ ^
        [1, 1], ^
        [TLEN(bmp, 10), 1], ^
        [1, TLEN(bmp, 1)], ^
        [TLEN(bmp, 10), TLEN(bmp, 1)] ^
    ])
    ASSERT(EQ(crop_same, bmp))
    DEL(crop_same)

    # SCALE with factor 2 (binary 10) doubles dimensions
    TNS: scaled2 = image.SCALE(bmp, 10, 10, 1)
    ASSERT(EQ(image.WIDTH(scaled2), MUL(image.WIDTH(bmp), 10)))
    ASSERT(EQ(image.HEIGHT(scaled2), MUL(image.HEIGHT(bmp), 10)))
    DEL(scaled2)

    # ROTATE by 0 degrees is identity
    TNS: rot0 = image.ROTATE(bmp, 0.0)
    ASSERT(EQ(rot0, bmp))
    DEL(rot0)

    # BLIT with mixalpha=0 should copy pixels exactly
    TNS: canvas2 = TNS(SHAPE(bmp), 0)
    TNS: blit_out = image.BLIT(bmp, canvas2, 1, 1, 0)
    DEL(canvas2)
    ASSERT(EQ(image.PIXEL(blit_out, 1, 1), image.PIXEL(bmp, 1, 1)))
    DEL(bmp)
    DEL(blit_out)

    # Shape drawing and primitive operators
    # small canvas: 11x11x4 (binary 1011 = 11, 100 = 4 channels)
    TNS: small = TNS([1011,1011,100], 0)
    TNS: red = [11111111, 0, 0, 11111111]

    # RECT / RECTANGLE / SQUARE / FILL_RECT
    TNS: rect_out = image.RECT(small, 10, 10, 101, 101, red, 1, 1)
    ASSERT(EQ(TLEN(rect_out, 1), TLEN(small, 1)))
    ASSERT(EQ(rect_out[10,10,1], red[1]))
    DEL(rect_out)

    TNS: rect2 = image.RECTANGLE(small, 10, 10, 101, 101, red, 1, 1)
    ASSERT(EQ(TLEN(rect2, 1), TLEN(small, 1)))
    DEL(rect2)

    TNS: sq = image.SQUARE(small, 10, 10, 101, red, 1, 1)
    ASSERT(EQ(TLEN(sq, 1), TLEN(small, 1)))
    DEL(sq)

    TNS: filled = image.FILL_RECT(small, 10, 10, 101, 101, red)
    ASSERT(EQ(TLEN(filled, 1), TLEN(small, 1)))
    DEL(filled)

    # ELLIPSE / FILL_ELLIPSE / CIRCLE
    TNS: ell = image.ELLIPSE(small, [100,100], 11, 101, red, 1, 1)
    ASSERT(EQ(TLEN(ell, 1), TLEN(small, 1)))
    DEL(ell)

    TNS: fill_ell = image.FILL_ELLIPSE(small, [100,100], 11, 101, red)
    ASSERT(EQ(TLEN(fill_ell, 1), TLEN(small, 1)))
    DEL(fill_ell)

    TNS: circ = image.CIRCLE(small, [100,100], 11, red, 1, 1)
    ASSERT(EQ(TLEN(circ, 1), TLEN(small, 1)))
    DEL(circ)

    # POLYGON
    TNS: pts = [ ^
        [10, 10], ^
        [110, 10], ^
        [100, 110], ^
        [10, 10] ^
    ]
    TNS: poly = image.POLYGON(small, pts, red, 1, 1)
    ASSERT(EQ(TLEN(poly, 1), TLEN(small, 1)))
    DEL(poly)

    # Cleanup small canvas
    DEL(small)
    DEL(red)

    PRINT("Image library tests passed.")
    PRINT()
    RETURN(0)
}

FUNC STDEXT_TESTS():INT{

    PRINT("Running extension tests...")

    # win32 extension
    ASSERT(EQ(win32.WIN_SLEEP(0), 0))
    INT: ticks = win32.WIN_CALL("kernel32", "GetTickCount64", "", "I")
    ASSERT(GTE(ticks, 0))
    INT: last_err = win32.WIN_LAST_ERROR()
    ASSERT(GTE(last_err, 0))
    PRINT("win32 extension tests passed.")

    # networking extension (local-only; no external internet required)
    INT: udp = networking.UDP_BIND("127.0.0.1", 0)
    ASSERT(GT(udp, 0))
    ASSERT(EQ(networking.UDP_CLOSE(udp), 0))
    PRINT("networking extension tests passed.")

    # wasapi extension (read-only queries)
    STR: devname = wasapi.WASAPI_GET_DEFAULT_DEVICE_NAME()
    ASSERT(GT(SLEN(devname), 0))
    INT: volpct = wasapi.WASAPI_GET_MASTER_VOLUME()
    ASSERT(GTE(volpct, 0))
    ASSERT(LTE(volpct, 1100100))  # dec 100
    PRINT("wasapi extension tests passed.")

    PRINT()
    RETURN(0)
}

FUNC RUN_TESTS():INT{
    STDLIB_TESTS()
    STDEXT_TESTS()
    PRINT("All tests passed.")
    RETURN(0)
}

IF( EQ(MAIN(), 1) ){ RUN_TESTS() }